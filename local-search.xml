<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>数据结构错题复习</title>
    <link href="/2023/12/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%94%99%E9%A2%98%E5%A4%8D%E4%B9%A0/"/>
    <url>/2023/12/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%94%99%E9%A2%98%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<font face="宋体"><h2 id="1-3章"><a href="#1-3章" class="headerlink" title="1~3章"></a>1~3章</h2><p><strong>数据结构基本定义</strong>：<br>1：数据的逻辑结构说明数据元素之间的顺序关系，它依赖于计算机的存储结构。<br>答：错.<br>说明：逻辑结构可用不同的存储结构实现，“它依赖于计算机的存储结构”完全说不通。<br>2. 逻辑结构是指数据元素之间的逻辑关系，与数据的存储无关，独立于计算机。<br>3. <img src="/2023-12-31-13-58-10.png"><br>4. 数据的逻辑结构分为线性结构和非线性结构。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py">顺序存储：把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。<br>链式存储：借助指示元素存储地址的指针来表示元素之间的逻辑关系。<br>索引存储：在存储元素信息的同时，还建立附加的索引表。<br>散列存储：根据元素的关键字直接计算出该元素的存储地址，又称哈希（<span class="hljs-built_in">hash</span>）存储。<br></code></pre></td></tr></table></figure><p><strong>算法和时间复杂度</strong>：</p><ol><li>算法可以有<strong>0个输入</strong>，但是一定要有<strong>一个以上的输出</strong>。</li><li>算法分析是分析<strong>效率加以改进</strong></li><li><img src="/2023-12-31-14-03-24.png"></li></ol><p><strong>顺序表</strong>：</p><ol><li>线性表的长度是线性表中元素的个数（<strong>与所占用的存储空间无关</strong>）</li><li><del>线性表</del>&#x3D;&#x3D;顺序表&#x3D;&#x3D;的插入、删除总是伴随着大量数据的移动。</li><li>要区别&#x3D;&#x3D;第i个位置&#x3D;&#x3D;，顺序表的存储是从0开始的，所以计算移动次数的时候要注意i，查找的时候也是找i-1位置上的元素。</li><li>合并两个顺序表的关键</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1.</span> 要判断lena+lenb&gt;maxlenc <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-number">2.</span> 开始合并<br><span class="hljs-keyword">while</span>(i&lt;lena&amp;&amp;b&lt;lenb) c[k++]=a[i]&lt;b[j]?a[i++]:b[j++];<br><span class="hljs-keyword">while</span>(i&lt;lena) c[k++]=a[i++];<br><span class="hljs-keyword">while</span>(j&lt;lenb) c[k++]=b[j++];<br>lenc=k;<br></code></pre></td></tr></table></figure><p><strong>链表</strong>：<br>1.引入头结点的两个优点：（主要就是方便运算）</p><ul><li>由于第一个数据结点的位置被存放在头结点的指针域中，所以在链表的第一个位置上的操作和在表的其他位置上的操作一致，无需进行特殊处理。</li><li>无论链表是否为空，其头指针都指向头结点的非空指针（空表中头结点的指针域为空）。</li></ul><ol start="2"><li>查找操作</li></ol><ul><li>按序号查找和按值查找都是O(n)的复杂度。</li><li>关键是有头结点，所以一开始要<code>Londe *p=L-&gt;next</code>把第一个结点赋值给p</li><li><strong>计算平均查找长度</strong>：<img src="/2023-12-31-14-48-30.png" alt="·">计算思路：$1+2+3+…+n&#x3D;\frac{n(n+1)}{2}$ 平均可以得出 $ans&#x3D;\frac{前式子}{n}&#x3D;\frac{n+1}{2}$</li></ul><ol start="3"><li>插入操作</li></ol><p><img src="/2023-12-31-14-53-04.png" alt="2"></p><p><strong>堆栈</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">下列关于栈的叙述中，错误的是：<br><br><span class="hljs-number">1.</span> 采用非递归方式重写递归程序时必须使用栈（斐波那契数列）<br><span class="hljs-number">2.</span> 函数调用时，系统要用栈保存必要的信息<br><span class="hljs-number">3.</span> 只要确定了入栈次序，即可确定出栈次序（不一定的，可能中间插入）<br><span class="hljs-number">4.</span> 栈是一种受限的线性表，允许在其两端进行操作（一端）<br><br><span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>为错误<br></code></pre></td></tr></table></figure><p>&#x3D;&#x3D;排序问题&#x3D;&#x3D;：<br><img src="/2023-12-31-14-57-53.png"></p><p><img src="/2023-12-31-15-11-06.png"></p><p><strong>循环队列</strong>：<br>&#x3D;&#x3D;普通队列不能用<code>Q.rear==MAXSIZE</code>当作队满条件&#x3D;&#x3D;<br>保留一个元素空间，当队尾指针指的空闲单元的后继单元是队头元素所在单元时，队满。<br>队满的条件为 <strong>(Q.rear+1)%MAXSIZE&#x3D;&#x3D;Q.front</strong>；<br>队空的条件为 <strong>Q.rear&#x3D;&#x3D;Q.front</strong><br>队列的长度为 <strong>(Q.rear+MAXSIZE-Q.front)%MAXSIZE</strong><br>如果循环队列用大小为 m 的数组表示，队头位置为 front、队列元素个数为 size，那么队尾元素位置 rear 为：**(front+size-1)%m**</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*求队列长度*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">QueueLength</span><span class="hljs-params">(SeQueue *Q)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> (Q-&gt;rear-Q-&gt;front+MAXSIZE)%MAXSIZE;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>错题总结</strong>：</p><ol><li>数据结构在计算机内存中的表示是指&#x3D;&#x3D;数据的存储结构&#x3D;&#x3D;</li><li>线性表、堆栈、队列的主要区别是&#x3D;&#x3D;堆栈和队列都是插入、删除受到约束的线性表&#x3D;&#x3D;</li><li>若一个栈的输入序列为1，2，3，…，N，输出序列的第一个元素是i，则第j个输出元素是aj &#x3D; i-(j-1) &#x3D; i-j+1.</li><li>n维数组中每个元素都可以看作是n-1维的线性表，一直递推到1维即为一维线性表。<img src="/2023-12-31-15-28-11.png" alt="。"></li><li>对于一非空的循环单链表，h和p分别指向链表的头、尾结点，则有<code>p-&gt;next=h</code></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">6</span>、以下关于数据结构的说法中，正确的是（A）<br>A、数据的逻辑结构独立于其存储结构<br>B、数据的存储结构独立于其逻辑结构<br>C、数据的逻辑结构唯一决定了其存储结构<br>D、数据结构仅由其逻辑结构和存储结构决定<br>解析：<br>A数据的逻辑结构是以面向实际问题的角度出发的，只采用抽象表达方式，独立于存储结构。<br>B数据的存储结构是逻辑结构在计算机上的映射，它不能独立与逻辑结构而存在。<br>C满二叉树既可以用顺序存储方式存储，也可以用链式存储结构存储。<br>D数据结构包括三个要素（逻辑结构、存储结构、数据运算），缺一不可。<br>逻辑结构有四种基本类型：集合结构、线性结构、树状结构和网络结构。<br>两种基本的存储结构：顺序存储结构和链式存储结构。<br></code></pre></td></tr></table></figure><ol start="7"><li>在数据结构中，与所使用的计算机无关的数据结构是&#x3D;&#x3D;逻辑结构&#x3D;&#x3D;</li><li><del>除数组外，每种数据结构都应具备3种基本运算：插入、删除和査找</del></li><li>如果循环队列用大小为m的数组表示，且用队头指针front和队列元素个数size代替一般循环队列中的front和rear指针来表示队列的范围，那么这样的循环队列可以容纳的元素个数&#x3D;&#x3D;最多为m&#x3D;&#x3D;。因为：有了size后就不必留一个空间表示队列满了，所以答案为m。正常来讲，front &#x3D;&#x3D; rear 既可以表示只有一个元素，或者满元素。所以如果没有size的话，答案应该是&#x3D;&#x3D;m-1&#x3D;&#x3D;。有了size，只需根据数组大小来判断元素个数。</li><li>当栈中元素为n个，作进栈运算时发生上溢，则说明该栈的最大容量为(n)。</li><li>定义逻辑结构时可不考虑存储结构</li></ol><h2 id="4-to6章"><a href="#4-to6章" class="headerlink" title="$4\to6章$"></a>$4\to6章$</h2><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>层序遍历</p><ol><li>如果 e 是有权无向图 G <strong>唯一的一条最短边</strong>，那么边e <strong>一定</strong>会在该图的最小生成树上。</li><li>若图G为连通图，则G必有唯一的一棵最小生成树。<strong>必有</strong> <strong>唯一</strong></li><li>N个元素的最大堆，随机访问任意值的操作不可以在O(logN)内完成</li><li>prim和kruskal都是贪心算法</li><li>平衡二叉树，所有非叶节点的平衡因子为0时，不一定是完全二叉树。</li><li>二叉排序树只有在中序遍历的时候是递增序列。</li><li>完全二叉搜索树的最小值一定在叶节点上。</li><li>哈夫曼编码的编码和长度都不是唯一的。</li><li><a href="https://www.nowcoder.com/questionTerminal/16d7ad3776ff4ef6b6c1dd9b359ea5e9?toCommentId=2097446">https://www.nowcoder.com/questionTerminal/16d7ad3776ff4ef6b6c1dd9b359ea5e9?toCommentId=2097446</a></li><li>二叉搜索树的搜索效率和深度相关</li><li>完全二叉树不一定存在度为1的结点</li><li>完全二叉树如果没有左孩子，则一定是树叶</li><li>树可以找到唯一的一颗二叉树与之对应</li><li>链表存储包含n个结点的二叉树，结点的2n个指针域中有n+1个空指针。**因为一棵树n个结点一定有n-1条边，所以是2n-(n-1)**。</li><li>对于树而言，树的度为树内各结点最大的度。</li><li><a href="https://www.nowcoder.com/questionTerminal/11ded0e72b6242cc8357f56fb70000cd">https://www.nowcoder.com/questionTerminal/11ded0e72b6242cc8357f56fb70000cd?</a></li><li><strong>过滤法建立最大堆</strong></li><li><strong>判断最小堆</strong></li><li>一颗树所有的出度之和为n-1<img src="/2023-12-18-17-00-54.png"></li><li>通过后序遍历+中序遍历得到前序遍历。</li><li><a href="https://zhidao.baidu.com/question/299599173.html">https://zhidao.baidu.com/question/299599173.html</a></li><li>链表存储二叉树，子节点条件。</li><li>深度为k的完全二叉树至多有____至少有____</li><li>高度为8的完全二叉树至少有____个叶子结点</li><li>任何结点至多只有右子女的时候，二叉树先序序列和中序序列相同</li></ol><h3 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h3><ol><li><strong>同义词的定义</strong>：在散列表中，所谓同义词就是具有相同散列地址的两个元素。</li><li>在散列中，函数“插入”和“查找”具有同样的时间复杂度。</li><li>hash表的平均查找长度与处理冲突的方法有关。</li><li>如果使用二次探测来解决冲突，那么如果哈希表的大小是素数，则新的插入必须成功。 <strong>F</strong></li></ol><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><ol><li>在一个有向图中，所有顶点的入度与出度之和等于所有边之和的2倍。</li><li>用邻接矩阵法存储图，占用的存储空间数只与图中结点个数有关，而<strong>与边数无关</strong>。用<strong>邻接表</strong>法存储图，占用的存储空间数与<strong>图中结点个数和边数有关</strong>。</li><li>在一个有权无向图中，若b到a的最短路径距离是12，且c到b之间存在一条权为2的边，则c到a的最短路径距离一定不小于10。<strong>正确的</strong><img src="/2023-12-18-16-33-42.png"></li><li><strong>AOE</strong><img src="/2023-12-18-17-15-56.png"></li><li>同义词again：<img src="/2023-12-20-16-15-09.png"></li><li>对于带权无向图 G &#x3D; (V, E)，M 是 G 的最小生成树，则 M 中任意两点 V1 到 V2 的路径一定是它们之间的最短路径。（因为都是根据贪心算法来实现的）</li><li><strong>装填因子</strong>：<img src="/2023-12-20-16-17-11.png"></li><li>一个无向图G，若某顶点v到其它每个顶点都有至少一条路径，则图G只有1个连通分量。（就是没有互不连通的子图）</li><li><strong>AOE定义</strong>：在AOE网络中，从源点到汇点具有最大长度的路径称为关键路径。完成AOE所表示的整个工程所需要的时间取决于关键路径的路径长度</li><li>若图G为<strong>连通图</strong>且<strong>不存在拓扑排序序列</strong>，则图G必有环。</li><li><strong>Kruskal 算法是维护一个森林，每一步把两棵树合并成一棵。</strong></li><li><strong>prim和kruskal的区别</strong>：<img src="/2023-12-20-16-21-07.png"></li><li><strong>AOE图的关键路径就是最长的路径</strong></li><li>具有n个顶点、e条边的无向图，若用邻接矩阵作为存储结构，则求任何顶点的度数的时间复杂度为O(n)。</li><li>如果无向图G必须进行两次广度优先搜索才能访问其所有顶点，则G中一定有回路。<strong>不一定，还可能存在2个连通分量</strong></li><li><a href="https://blog.csdn.net/super_iron_man/article/details/111075347">https://blog.csdn.net/super_iron_man/article/details/111075347</a></li><li>任何无向图都存在生成树 <strong>F-非连通的图没有生成树。这是由生成树的定义决定的：生成树是连通图的包含图中的所有顶点的极小连通子图。如果原图不连通，则不可能存在包含原图中所有顶点的连通子图。</strong></li><li><strong>AOE图的权值最大的边（活动）一定是关键活动。</strong></li><li><strong>算法与数据结构复习 第六章 图（详解）</strong>:<a href="https://blog.csdn.net/weixin_43751983/article/details/103392635">https://blog.csdn.net/weixin_43751983/article/details/103392635</a></li><li>如果从有向图 G 的每一点均能通过深度优先搜索遍历到所有其它顶点，则该图是一个有环图；而拓扑排序的前提是有向无环图；</li><li><strong>prim</strong>算法是通过每步添加一条边及其相连的顶点到一棵树，从而逐步生成最小生成树；<strong>Kruskal</strong> 算法是维护一个森林，每一步把两棵树合并成一棵。</li><li><a href="https://blog.csdn.net/weixin_45525272/article/details/111355410">https://blog.csdn.net/weixin_45525272/article/details/111355410</a></li><li><img src="/2023-12-20-16-53-59.png"></li></ol></font>]]></content>
    
    
    <categories>
      
      <category>期末复习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构错题复习</title>
    <link href="/2023/12/14/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    <url>/2023/12/14/%E5%A4%8D%E4%B9%A0%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<font face="宋体"><h1 id="期末复习"><a href="#期末复习" class="headerlink" title="期末复习"></a>期末复习</h1><h2 id="各科目考试时间安排"><a href="#各科目考试时间安排" class="headerlink" title="各科目考试时间安排"></a>各科目考试时间安排</h2><table><thead><tr><th align="center">科目</th><th align="center">考试时间</th><th align="center">还有多久</th></tr></thead><tbody><tr><td align="center">离散</td><td align="center">23-12-28</td><td align="center">16 d</td></tr><tr><td align="center">数据结构</td><td align="center">24-1-3</td><td align="center">22 d</td></tr><tr><td align="center">计组</td><td align="center">24-1-4</td><td align="center">23 d</td></tr><tr><td align="center">数分</td><td align="center">24-1-9</td><td align="center">28 d</td></tr><tr><td align="center">线代</td><td align="center">24-1-10</td><td align="center">29 d</td></tr><tr><td align="center">大物</td><td align="center">24-1-11</td><td align="center">30 d</td></tr><tr><td align="center">概率论</td><td align="center">24-1-12</td><td align="center">31 d</td></tr><tr><td align="center">c语言</td><td align="center">24-1-15</td><td align="center">34 d</td></tr></tbody></table><h2 id="具体每天安排"><a href="#具体每天安排" class="headerlink" title="具体每天安排"></a>具体每天安排</h2><ol><li>离散</li><li>数据结构</li><li>计组</li></ol><p>课业部分：</p><ul><li>数分-每周3个</li><li>概率论-每周2个</li><li>数据结构-到12&#x2F;18</li><li>大物-两周一次</li><li>线代自己找-每周1个</li></ul><h2 id="离散"><a href="#离散" class="headerlink" title="离散"></a>离散</h2><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p>总共 4 章 25个小知识点</p><ul><li>19 整数<ul><li>19.1 -&gt; 19.5</li><li>6节</li></ul></li><li>20 群<ul><li>20.1 -&gt; 20.6</li><li>6节</li></ul></li><li>21 环<ul><li>21.1 -&gt; 21.7</li><li>7节</li></ul></li><li>22 格+布尔代数<ul><li>22.1 -&gt; 21.6</li><li>6节</li></ul></li></ul><h3 id="复习资料"><a href="#复习资料" class="headerlink" title="复习资料"></a>复习资料</h3><ol><li>作业题目</li><li>试卷</li><li>ppt</li><li>课本</li><li>网课</li><li>去网上找题目刷</li></ol><h3 id="试卷分析"><a href="#试卷分析" class="headerlink" title="试卷分析"></a>试卷分析</h3><h3 id="错题"><a href="#错题" class="headerlink" title="错题"></a>错题</h3><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点-"></a>知识点-</h3><p>总共八章41个知识点</p><ul><li>1 概论<ul><li>1.1 -&gt; 1。4</li><li>4节</li></ul></li><li>2 数据结构基础<ul><li>2.1 -&gt; 2.3</li><li>3节</li></ul></li><li>3 线性结构<ul><li>3.1 -&gt; 3.5</li><li>5节</li></ul></li><li>4 树<ul><li>4.1 -&gt; 4.6</li><li>6节</li></ul></li><li>5 散列查找<ul><li>5.1 -&gt; 5.6</li><li>6节</li></ul></li><li>6 图<ul><li>6.1 -&gt; 6.9</li><li>9节</li></ul></li><li>7 排序<ul><li>7.1 -&gt; 7.8</li><li>8节</li></ul></li><li>8 综合应用<ul><li>8.1 -&gt; 8.2</li><li>2节</li></ul></li></ul><h3 id="复习资料-1"><a href="#复习资料-1" class="headerlink" title="复习资料-"></a>复习资料-</h3><ol><li>作业题目</li><li>实验题目</li><li>试卷</li><li>ppt</li><li>课本</li><li>网课</li><li>去网上找题目刷</li></ol><h3 id="试卷分析-1"><a href="#试卷分析-1" class="headerlink" title="试卷分析"></a>试卷分析</h3><h3 id="错题-1"><a href="#错题-1" class="headerlink" title="错题"></a>错题</h3><h2 id="计组"><a href="#计组" class="headerlink" title="计组"></a>计组</h2><h3 id="知识点–"><a href="#知识点–" class="headerlink" title="知识点–"></a>知识点–</h3><p>总共7章43个知识点</p><ul><li>1 概论<ul><li>1.1 -&gt; 1.6</li><li>6节</li></ul></li><li>2 运算方法和运算器<ul><li>2.1 -&gt; 2.5</li><li>5节</li></ul></li><li>3 存储系统<ul><li>3.1 -&gt; 3.7</li><li>7节</li></ul></li><li>4 总线<ul><li>4.1 -&gt; 4.6</li><li>6节</li></ul></li><li>5 指令系统<ul><li>5.1 -&gt; 5.7</li><li>7节</li></ul></li><li>6 cpu<ul><li>6.1 -&gt; 6.6</li><li>6节</li></ul></li><li>7 I&#x2F;O<ul><li>7.1 -&gt; 7.6</li><li>6节</li></ul></li></ul><h3 id="复习资料-2"><a href="#复习资料-2" class="headerlink" title="复习资料"></a>复习资料</h3><ol><li>作业题目</li><li>试卷</li><li>ppt</li><li>课本</li><li>网课</li><li>去网上找题目刷</li></ol><h3 id="试卷分析-2"><a href="#试卷分析-2" class="headerlink" title="试卷分析"></a>试卷分析</h3><h3 id="错题-2"><a href="#错题-2" class="headerlink" title="错题"></a>错题</h3></font>]]></content>
    
    
    <categories>
      
      <category>期末复习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>重载运算符</title>
    <link href="/2023/11/13/objetc/"/>
    <url>/2023/11/13/objetc/</url>
    
    <content type="html"><![CDATA[<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><ul><li><p><code>const</code>是为了防止做左值</p></li><li><p>+&#x3D;*&#x2F;%^&amp;|~</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-type">const</span> T operate +=*/%^&amp;|~(<span class="hljs-type">const</span> T&amp; l,<span class="hljs-type">const</span> T&amp; r) <span class="hljs-type">const</span>;<br></code></pre></td></tr></table></figure><ul><li>! &amp;&amp; || &lt; &lt;&#x3D; &#x3D;&#x3D; &#x3D;&gt; &gt;</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">bool</span> operate ! &amp;&amp; || &lt; &lt;= == =&gt; &gt; (<span class="hljs-type">const</span> T&amp; l,<span class="hljs-type">const</span> T&amp; r)<span class="hljs-type">const</span>;<br></code></pre></td></tr></table></figure><ul><li>[]</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">T&amp; T::operate[](<span class="hljs-type">int</span> index);<span class="hljs-comment">// 因为要做左值，所以是返回reference</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构记录</title>
    <link href="/2023/10/10/data%20structure/"/>
    <url>/2023/10/10/data%20structure/</url>
    
    <content type="html"><![CDATA[<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="链表的基本结构"><a href="#链表的基本结构" class="headerlink" title="链表的基本结构"></a>链表的基本结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span><br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">next</span>;</span><span class="hljs-comment">//关键了属于是</span><br>&#125;node;<br><br></code></pre></td></tr></table></figure><h3 id="对链表应该进行的操作"><a href="#对链表应该进行的操作" class="headerlink" title="对链表应该进行的操作"></a>对链表应该进行的操作</h3><ol><li>初始化函数<code>node* list_init();</code><br>关键就是先建立再指向，最后返回head，链表就成了，很抽象。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c">node* <span class="hljs-title function_">list_init</span><span class="hljs-params">()</span>&#123;<span class="hljs-comment">// 要返回指向node的指针</span><br>    <span class="hljs-type">int</span> d;<br>    node *head=<span class="hljs-literal">NULL</span>,*str=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">// 初始化head是头，str用来继续生成</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;d);<br>    <span class="hljs-keyword">while</span>(d!=<span class="hljs-number">-1</span>)&#123;<span class="hljs-comment">// 这个是题目要求</span><br>        node *p=(node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<span class="hljs-comment">// 申请空间</span><br>        p-&gt;data=d;<br>        p-&gt;next=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">// 新的结点总是要指向NULL</span><br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">NULL</span>) head=p;<br>        <span class="hljs-keyword">else</span> str-&gt;next=p;<span class="hljs-comment">// 用来链接previous and current</span><br>        str=p; <span class="hljs-comment">// 关键 把链表构成了</span><br>        <span class="hljs-comment">//free(p);// 不可以执行的操作</span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;d);<br>    &#125;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二个版本：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><br>node* <span class="hljs-title function_">list_init</span><span class="hljs-params">()</span>&#123;<span class="hljs-comment">// 要返回指向node的指针</span><br>    <span class="hljs-type">int</span> d;<br>    node *str;<span class="hljs-comment">// 初始化head是头，str用来继续生成</span><br>    node *head=(node *)<span class="hljs-built_in">malloc</span>(sizeod(node));<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;d);<br>    head-&gt;data=d;<br>    head-&gt;next=<span class="hljs-literal">NULL</span>;<br>    str=head;<br>    <span class="hljs-keyword">while</span>(d!=<span class="hljs-number">-1</span>)&#123;<span class="hljs-comment">// 这个是题目要求</span><br>        node *p=(node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(node));<br>        <span class="hljs-comment">// 先建立再指向</span><br>        p-&gt;data=d;<br>        p-&gt;next=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">// 新的结点总是要指向NULL</span><br>        str-&gt;next=p;<span class="hljs-comment">// 用来链接previous and current</span><br>        str=p; <span class="hljs-comment">// 关键 把链表构成了</span><br>        <span class="hljs-comment">// free(p); // 错误的，如果free掉p,那么我们初始化的那个链表就没有结尾了</span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;d);<br>    &#125;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C/CPP</category>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>VERILOG language</title>
    <link href="/2023/09/29/learning%20verilog/"/>
    <url>/2023/09/29/learning%20verilog/</url>
    
    <content type="html"><![CDATA[<h2 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h2><p>用for循环：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> top_module( <br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">99</span>:<span class="hljs-number">0</span>] in,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">99</span>:<span class="hljs-number">0</span>] out<br>);<br>    <span class="hljs-keyword">integer</span> i;<br>    <span class="hljs-keyword">always</span>@(*) <span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;i++)<br>            out[i]=in[<span class="hljs-number">99</span>-i];<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><h2 id="逻辑和位运算符和c一样"><a href="#逻辑和位运算符和c一样" class="headerlink" title="逻辑和位运算符和c一样"></a>逻辑和位运算符和c一样</h2><p>不过要注意<code>&amp;a</code>或者<code>|a</code>是把a的每一位都进行这个操作，比如:&amp;a[n:0]&#x3D;a[0]&amp;a[1]…&amp;a[n];</p><h2 id="符号"><a href="#符号" class="headerlink" title="{}符号"></a>{}符号</h2><ol><li>用于拼接，可以有骚操作：<code>assign out=&#123;in[0],in[1],in[2],in[3],in[4],in[5],in[6],in[7]&#125;;</code></li><li>用于复制粘贴：<img src="/img/2023-09-29-11-18-00.png"><br>要注意是<code>&#123;&#123;num&#123;bit&#125;,vector&#125;&#125;</code></li></ol><h2 id="两种声明模块的方法"><a href="#两种声明模块的方法" class="headerlink" title="两种声明模块的方法"></a>两种声明模块的方法</h2><p><img src="/img/2023-09-29-11-53-06.png"><br><img src="/img/2023-09-29-11-53-28.png"></p><h2 id="case的用法"><a href="#case的用法" class="headerlink" title="case的用法"></a>case的用法</h2><ol><li>在<code>always@(*)begin..。end</code>中使用</li><li>使用格式:</li></ol><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">always</span>@(*)<br><span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">case</span>(变量)<span class="hljs-comment">//没有冒号！！！！！！</span><br>        <span class="hljs-number">2&#x27;b01</span>:<span class="hljs-keyword">begin</span> ... ;<span class="hljs-keyword">end</span><br>        .<br>        .<br>        .<br>        <span class="hljs-keyword">default</span>:<span class="hljs-keyword">begin</span> ... ;<span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">endcase</span><span class="hljs-comment">//关键</span><br><span class="hljs-keyword">end</span><br><br></code></pre></td></tr></table></figure><h2 id="alawys语句"><a href="#alawys语句" class="headerlink" title="alawys语句"></a>alawys语句</h2><ol><li>可以替代assign :<img src="/img/2023-10-01-20-20-55.png"></li><li>像case、if、for都只能在always里用</li></ol><h2 id=""><a href="#" class="headerlink" title="&lt;&#x3D; 和 &#x3D;"></a>&lt;&#x3D; 和 &#x3D;</h2><p><img src="/img/2023-10-02-14-50-41.png"></p><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p><img src="/img/2023-10-02-14-56-34.png"></p>]]></content>
    
    
    <categories>
      
      <category>计组</category>
      
      <category>verilog</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>POINT</title>
    <link href="/2023/09/20/point%20on%20c%201/"/>
    <url>/2023/09/20/point%20on%20c%201/</url>
    
    <content type="html"><![CDATA[<h2 id="指针基础知识"><a href="#指针基础知识" class="headerlink" title="指针基础知识"></a>指针基础知识</h2><ol><li>指针变量的定义：比如<code>int *</code>是<strong>指向整型的指针</strong>；</li><li>指针的初始化：<code>type ch=?; type *cp=&amp;ch</code>；  即初始化要用<code>&amp;</code>来生成地址。</li><li>强制转化成指针变量用：<code>(type *)</code>比如<code>*100=200</code>是不合法的，但是<code>*(int *) 100=200</code>是合法的。</li><li>指针的指针：<code>int **c</code>即<code>int *(*c)</code>。</li><li>正常的非指针<code>char ch=&#39;a;</code>这句语句内，<code>ch</code>当左值的时候是<strong>地址，而不是该地址所包含的值</strong>，<code>ch</code>是右值的时候才是表达式的值，<strong>所以，可以说这句语句是把<code>&#39;a&#39;</code>存入<code>ch</code>的地址内</strong>。</li><li>如果<code>int ch=100;int *cp=&amp;ch;</code>那么<strong>cp&#x3D;&amp;ch</strong>。</li><li>可以看出<code>*cp</code>作为<strong>右值</strong>的时候是间接访问符访问，对应的值是访问地址所存变量的值，如果依照<code>6.</code>的初始化,那么就是100(ch)；<del>作为<strong>左值</strong>的时候，是指向初始话变量的地址，所以指针的初始化是<code>*cp=&amp;ch</code>。</del> 在严谨的编译器里<code>*cp</code>不能单独出来作左值，就算在不严谨的编译器里，也<strong>最好不要用<code>*cp</code>来作左值</strong>。上面删除那行只能在<code>int *</code>那行成立。</li><li>现在讨论<code>*(cp + 1)</code>(<code>*cp + 1</code>只能做右值，结果很显然)，作<strong>右值</strong>的时候，是在地址位(&amp;ch+4)的值，因为没有初始化所以是未知的；作<strong>左值</strong>的时候就是(&amp;ch+4)的地址，直接输出<code>cp+1</code>可见，(cp+1)&#x3D;&amp;ch+4(这里可以插入一下，<img src="/img/2023-09-22-15-34-23.png"><img src="/img/2023-09-22-15-42-52.png">)  <strong>IN ALL</strong>:<code>cp+1</code>就是访问下一个地址。</li></ol>]]></content>
    
    
    <categories>
      
      <category>C/CPP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>nand to tetris unit 3</title>
    <link href="/2023/09/19/nand%20p%20I%20unit%203/"/>
    <url>/2023/09/19/nand%20p%20I%20unit%203/</url>
    
    <content type="html"><![CDATA[<h2 id="sequential-logic"><a href="#sequential-logic" class="headerlink" title="sequential logic"></a>sequential logic</h2><h3 id="the-clock"><a href="#the-clock" class="headerlink" title="the clock"></a>the clock</h3><p><img src="/img/2023-09-19-13-05-21.png"><br><img src="/img/2023-09-19-13-07-51.png"></p><h3 id="combinatorial-组合-logic-sequential-logic"><a href="#combinatorial-组合-logic-sequential-logic" class="headerlink" title="combinatorial(组合) logic &amp; sequential logic"></a>combinatorial(组合) logic &amp; sequential logic</h3><p><img src="/img/2023-09-19-13-10-49.png"><br><img src="/img/2023-09-19-13-13-46.png"></p>]]></content>
    
    
    <categories>
      
      <category>计组</category>
      
      <category>nand part I</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/09/18/hello-world/"/>
    <url>/2023/09/18/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>binary multiplication</title>
    <link href="/2023/09/17/binary%20multiplication/"/>
    <url>/2023/09/17/binary%20multiplication/</url>
    
    <content type="html"><![CDATA[<h2 id="binary-addition-and-subtraction"><a href="#binary-addition-and-subtraction" class="headerlink" title="binary addition and subtraction"></a>binary addition and subtraction</h2><p>move to the nand p I unit 2</p><h2 id="binary-signed-multiplication"><a href="#binary-signed-multiplication" class="headerlink" title="binary signed multiplication"></a>binary signed multiplication</h2><p>tips: binary numbers are written with the<strong>MSB</strong>(Most-significant bit) in the left-most position; the <strong>LSB</strong>(Least-significant bit) is the furthest-right bit</p><ol><li>n-bits * n-bits &lt;&#x3D; 2*n-bits:<img src="/img/2023-09-17-14-15-20.png"></li><li>用补码计算二进制的时候，会把符号位扩充到八位：<img src="/img/2023-09-17-14-18-57.png"></li><li>计算过程的补位：<img src="/img/2023-09-17-14-33-36.png"></li><li>如果乘数的MSB或者说符号位是1，那么这一位乘出来的乘积需要减去：<img src="/img/2023-09-17-15-01-50.png">但是，减法即是取补码做加法：<img src="/img/2023-09-17-15-04-56.png">这里的补码是全部都要取反再+1，因为符号位在很前面</li></ol><h2 id="bianry-division"><a href="#bianry-division" class="headerlink" title="bianry division"></a>bianry division</h2><p>1. </p><h2 id="真值、机器数"><a href="#真值、机器数" class="headerlink" title="真值、机器数"></a>真值、机器数</h2><p><img src="/img/2023-09-17-21-35-13.png"></p><h2 id="符号、进位、溢出"><a href="#符号、进位、溢出" class="headerlink" title="符号、进位、溢出"></a>符号、进位、溢出</h2><p><img src="/img/2023-09-17-21-57-43.png"><br><img src="/img/2023-09-17-21-58-26.png"><br><img src="/img/2023-09-17-22-00-43.png"></p><h2 id="第一次作业须知"><a href="#第一次作业须知" class="headerlink" title="第一次作业须知"></a>第一次作业须知</h2><ol><li>[-Y]补&#x3D;[Y]补全部求反</li><li>求补码要注意原码是正数还是负数</li><li><img src="/img/2023-09-17-22-45-09.png"></li></ol><h2 id="booth-algorithm（乘法补码运算）"><a href="#booth-algorithm（乘法补码运算）" class="headerlink" title="booth algorithm（乘法补码运算）"></a>booth algorithm（乘法补码运算）</h2><p><img src="/img/2023-09-20-10-10-09.png"><br><img src="/img/2023-09-20-10-31-06.png"><br><img src="/img/2023-09-20-10-33-45.png"></p><h3 id="implement-in-hardware"><a href="#implement-in-hardware" class="headerlink" title="implement in hardware"></a>implement in hardware</h3><p>something</p><h3 id="补充一个快速求补码的思路"><a href="#补充一个快速求补码的思路" class="headerlink" title="补充一个快速求补码的思路"></a>补充一个快速求补码的思路</h3><p>从右往左碰到的第一个<code>1</code>不变，其余翻转。（符号位也不变）</p>]]></content>
    
    
    <categories>
      
      <category>计组</category>
      
      <category>binary computing</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>learn to use vim</title>
    <link href="/2023/09/16/to%20use%20vim/"/>
    <url>/2023/09/16/to%20use%20vim/</url>
    
    <content type="html"><![CDATA[<h2 id="cmd的操作"><a href="#cmd的操作" class="headerlink" title="cmd的操作"></a>cmd的操作</h2><ol><li><code>:sp</code>打开窗口，可以打开多个</li><li><code>:qa</code>退出全部</li><li><code>:tabnew</code>打开缓冲区</li><li><code>^w</code>+<code>w</code>+<code>j/k</code>实现窗口间光标的移动（normal）</li></ol><h2 id="normal"><a href="#normal" class="headerlink" title="normal"></a>normal</h2><ol><li><code>w</code>前进到下一个单词的头部</li><li><code>b</code>后退到下一个单词的头部</li><li><code>e</code>到单词尾部（前进）</li><li></li></ol>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>to build a own chatgpt</title>
    <link href="/2023/09/12/how%20to%20build%20up%20a%20own%20ChatGPT/"/>
    <url>/2023/09/12/how%20to%20build%20up%20a%20own%20ChatGPT/</url>
    
    <content type="html"><![CDATA[<h2 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h2><ol><li>apikey</li><li>服务器</li></ol>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数学自救指南</title>
    <link href="/2023/09/12/proof%20of%20math/"/>
    <url>/2023/09/12/proof%20of%20math/</url>
    
    <content type="html"><![CDATA[<h2 id="看证明的思考"><a href="#看证明的思考" class="headerlink" title="看证明的思考"></a>看证明的思考</h2><ol><li>策略：思路</li><li>技术：都会的基础方法</li><li>技巧：很巧妙的方法，关键性的一步</li></ol>]]></content>
    
    
    <categories>
      
      <category>math</category>
      
      <category>proof</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>nand to tetris unit 2</title>
    <link href="/2023/09/12/nand%20p%20I%20unit%202/"/>
    <url>/2023/09/12/nand%20p%20I%20unit%202/</url>
    
    <content type="html"><![CDATA[<h2 id="binary-addtion"><a href="#binary-addtion" class="headerlink" title="binary addtion"></a>binary addtion</h2><h3 id="half-adder-and-full-adder"><a href="#half-adder-and-full-adder" class="headerlink" title="half adder and full adder"></a>half adder and full adder</h3><ol><li>distinction:<ul><li>half one is 2 bits num ,but full one is 3 bits num</li><li>when two 16-bit num add,they may contribute to the caryy,if only use half adder,we cannot get right result,because it cannot add the carry with the two 1-bit num.</li></ul></li></ol><h3 id="16-bit-adder"><a href="#16-bit-adder" class="headerlink" title="16-bit adder"></a>16-bit adder</h3><ol><li>structure:<ul><li>it can be built by 16 full adders or 15 full adders with just 1 half adder in the most left place.</li><li><img src="/img/2023-09-12-11-31-09.png"></li></ul></li></ol><h2 id="binary-division"><a href="#binary-division" class="headerlink" title="binary division"></a>binary division</h2><h3 id="negative-numbers"><a href="#negative-numbers" class="headerlink" title="negative numbers"></a>negative numbers</h3><ol><li><p>complement: replace -x (b) by 2^n - x (b):<img src="/img/2023-09-12-19-35-29.png"></p><ul><li>positive num:0<del>2^(n-1)-1(b) the above is 0</del>7 and 0000~0111</li><li>negative num:-1<del>-2^(n-1) the above is -1</del>-8 and 1111~1000</li></ul></li></ol><h3 id="achieve-the-division"><a href="#achieve-the-division" class="headerlink" title="achieve the division"></a>achieve the division</h3><p><img src="/img/2023-09-12-19-41-51.png"></p><ol><li>representation: both the two num(-x &amp; 2^n-x) , their results of mol 2 is same. Like,-3 and 13(4-bits)</li></ol><ul><li>tip: modulo 模运算</li></ul><h3 id="反码和补码原理"><a href="#反码和补码原理" class="headerlink" title="反码和补码原理"></a>反码和补码原理</h3><p><img src="/img/2023-09-12-19-51-23.png"></p><ol><li><p>以4bits为例子，2^n -1是1111，再-x，等价于求反，最后再+1，那么就是2^n - x的实现了。</p></li><li><p>那么在硬件里怎么做到快速的+1，要分成两种情况讨论，最右边为0和最右边为1</p><ul><li>先讨论最右边为0，直接翻转变成1就行</li><li>最右边为1，则一直翻转成0，直到碰到第一个0，把它翻转为1，然后停止。</li></ul></li></ol><h2 id="对于补码反码逻辑关系的思考-significant"><a href="#对于补码反码逻辑关系的思考-significant" class="headerlink" title="对于补码反码逻辑关系的思考(significant)"></a>对于补码反码逻辑关系的思考(significant)</h2><p>一个MSB或符号位为1的的binary，比如<strong>11011101</strong>，可以确定是一个负数，然后它的补码是<strong>00100011</strong>即35，因此可以确定<strong>11011101</strong>是-35。<br>in chinese:<img src="/img/2023-09-17-15-37-52.png"></p><h2 id="ALU-arithmetic-logic-unit-—-算术逻辑单元"><a href="#ALU-arithmetic-logic-unit-—-算术逻辑单元" class="headerlink" title="ALU(arithmetic logic unit)—-算术逻辑单元"></a>ALU(arithmetic logic unit)—-算术逻辑单元</h2><ol><li>what is ALU?<img src="/img/2023-09-12-20-02-09.png"></li></ol>]]></content>
    
    
    <categories>
      
      <category>计组</category>
      
      <category>nand part I</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>the replace of some easy words</title>
    <link href="/2023/09/07/vocabulary/"/>
    <url>/2023/09/07/vocabulary/</url>
    
    <content type="html"><![CDATA[<h2 id="as-the-title"><a href="#as-the-title" class="headerlink" title="as the title"></a>as the title</h2><ol><li>stride – development</li><li>fulfill – achieve (dream) &#x2F;履行</li><li>console – comfort</li><li>liability – responsibility</li><li>conquer – overcome</li><li>competent – qualified</li><li>inhabitant – resident</li><li>render – cause</li><li>halt – stop</li></ol>]]></content>
    
    
    <categories>
      
      <category>English</category>
      
      <category>vocabulary</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>宝可梦紫攻略</title>
    <link href="/2023/08/08/pokemon/"/>
    <url>/2023/08/08/pokemon/</url>
    
    <content type="html"><![CDATA[<h2 id="各属性主力以及培养"><a href="#各属性主力以及培养" class="headerlink" title="各属性主力以及培养"></a>各属性主力以及培养</h2><p>收集：炭小侍、小火龙</p><ol><li><p>水：涌跃鸭</p><ul><li>进化成狂狼舞鸭有530种族值</li></ul></li><li><p>火：卡迪狗</p><ul><li>39级之后在火之石进化，关键是学神速</li><li>种族值555</li></ul></li><li><p>草：兰螳花——打水岩石地面</p><ul><li>兰：唱反调（特性）带贝壳、绿叶风暴、终极吸取、青草场地、光合作用</li></ul></li><li><p>妖精：玛力露丽 &amp;&amp; 仙子伊布</p><ul><li>玛力露丽：嬉闹（已学）、水流裂破、鼓腹</li><li>仙子伊布：亲密度&#x2F;友好度+妖精系招式————假哭、冥想、破坏死光</li></ul></li><li><p>一般系：猫老大</p><ul><li>铁壁、剑舞、铁头</li></ul></li><li><p>幽灵：耿鬼&#x2F;弃世猴</p><ul><li>暂无</li></ul></li><li><p>格斗：路卡利欧</p><ul><li>固执、剑舞神速&#x2F;子弹拳近身战</li><li><a href="https://jingyan.baidu.com/article/e6c8503c4dc783a44e1a1807.html">https://jingyan.baidu.com/article/e6c8503c4dc783a44e1a1807.html</a></li></ul></li><li><p>超能：呆呆王</p><ul><li>瞬间遗忘、诡计、辅助力量</li></ul></li><li><p>恶钢：仆刀将军</p><ul><li>铁壁、刺耳声、移花接木、金属爆炸</li></ul></li><li><p>龙：快龙&#x2F;路咬烈鲨</p></li><li><p>电：电蛙</p><ul><li>节拍器</li></ul></li><li><p>毒：毒藻龙</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
      <category>pokemon</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>学到的算法</title>
    <link href="/2023/08/06/Algorithm/"/>
    <url>/2023/08/06/Algorithm/</url>
    
    <content type="html"><![CDATA[<font face="宋体"><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><p>快速幂的思路主要就是减少计算机做乘法的次数，从而达到提速的目的。<br>比如：3^10 的计算如果是用循环一个一个乘，那么要乘9次，但是如果用快速幂的想法就是，3^10 &#x3D;(3^2 )^5 &#x3D;9^5 ，这样计算机只做了5次乘法，继续下去就是9 * 9^4 &#x3D; 9 * ( 9^2 )^2 ,这样计算就会比用循环直接乘快非常多。</p><p>从上面的推到过程可以看到，在用快速幂计算的时候，会产生两种情况（设要计算a^b）：</p><ol><li>b为偶数，当b为偶数的时候，我们只需要将执行<code>a=a*a</code>以及<code>b=b/2</code>来实现我们的思路，但是<code>b=b/2</code>最终b&#x3D;1，会产生奇数，所以我们还要讨论奇数幂的情况，这是必然发生的。</li><li>b为奇数，当b为奇数的时候，比如上面的例子，一开始a&#x3D;3,b&#x3D;10；经过一轮快速幂之后,a&#x3D;9,b&#x3D;5，我们可以设置一个变量<code>ans</code>，用<code>ans</code>来存奇数情况下多出来的那一个乘数，即<code>ans=ans*a</code>，从而变成了ans&#x3D;9,a&#x3D;9,b&#x3D;4;继续快速幂到下一轮,ans&#x3D;9，a&#x3D;81,b&#x3D;2；再继续下去:ans&#x3D;9,a&#x3D;6561,b&#x3D;1,此时b再次成为奇数，<code>ans=ans*a</code>,所以ans&#x3D;9*6561。最后返回ans的值就是我们想要的值。</li><li>以3^10为参数列出:<br>3 10<br>a&#x3D;9        b&#x3D;5 ans&#x3D;1</li></ol><p>a&#x3D;81       b&#x3D;2 ans&#x3D;9<br>a&#x3D;6561     b&#x3D;1 ans&#x3D;9<br>a&#x3D;43046721 b&#x3D;0 ans&#x3D;59049<br>num&#x3D;59049(返回值)</p><p><img src="/img/2023-09-18-22-11-25.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">ksm</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span><span class="hljs-comment">//在整数范围代替pow </span><br>&#123;<br><span class="hljs-type">int</span> ans=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(b)<br>&#123;<br><span class="hljs-keyword">if</span>(b%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>) ans*=a;<br>a*=a;<br>b/=<span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="埃式筛选（后续再补充）"><a href="#埃式筛选（后续再补充）" class="headerlink" title="埃式筛选（后续再补充）"></a>埃式筛选（后续再补充）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 10000</span><br><br><span class="hljs-type">int</span> p[MAX+<span class="hljs-number">5</span>],prime[MAX+<span class="hljs-number">5</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;;<br><span class="hljs-type">void</span> <span class="hljs-title function_">GetPrime</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=MAX;i++)&#123;<br><span class="hljs-keyword">if</span>(!prime[i])&#123;<br>p[prime[<span class="hljs-number">0</span>]++]=i;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i*<span class="hljs-number">2</span>;j&lt;=MAX;j+=i)&#123;<br>prime[j]=<span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="欧拉筛"><a href="#欧拉筛" class="headerlink" title="欧拉筛"></a>欧拉筛</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 10000</span><br><br><span class="hljs-type">int</span> vis[MAX+<span class="hljs-number">5</span>],prime[MAX+<span class="hljs-number">5</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Euler</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=MAX;i++)&#123;<br><span class="hljs-keyword">if</span>(!vis[i]) prime[++prime[<span class="hljs-number">0</span>]]=i;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=prime[<span class="hljs-number">0</span>]&amp;&amp;i&lt;=MAX/prime[j];j++)&#123;<br>vis[i*prime[j]]=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(i%prime[j]==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="组合数（后续再补充）"><a href="#组合数（后续再补充）" class="headerlink" title="组合数（后续再补充）"></a>组合数（后续再补充）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 100</span><br><span class="hljs-type">int</span> C[MAX][MAX];<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    1</span><br><span class="hljs-comment">   1 1</span><br><span class="hljs-comment">  1 2 1</span><br><span class="hljs-comment">1 2 3 2 1</span><br><span class="hljs-comment">*/</span><br>C[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=c[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=C[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;MAX;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">2</span>*i;j++)&#123;<br>C[i][j]=C[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+C[i<span class="hljs-number">-1</span>][j];<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="binary-search"><a href="#binary-search" class="headerlink" title="binary search"></a>binary search</h2><ol><li>normally, to avoid i+j over the scale of <code>int</code>,we do this: <code>int m = i+(j-i)/2</code></li><li>二分查找伪代码</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><br>l=<span class="hljs-number">1</span>,r=len;<br><br><span class="hljs-keyword">while</span> l+ <span class="hljs-number">1</span> !=r<br><br>m= (l+r)/<span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">if</span> <span class="hljs-title function_">isBlue</span><span class="hljs-params">(m)</span><br>l=m;<br><span class="hljs-keyword">else</span><br>l=n;<br><span class="hljs-keyword">return</span> l or r;<br></code></pre></td></tr></table></figure><h2 id="dfs（depth-first-search）"><a href="#dfs（depth-first-search）" class="headerlink" title="dfs（depth first search）"></a>dfs（depth first search）</h2><p><img src="/img/2023-08-25-22-41-07.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br>__int64 num[<span class="hljs-number">8877711</span>];<br><span class="hljs-type">int</span> flag = <span class="hljs-number">1</span>;<span class="hljs-comment">//判断满足题意的某个数的序号</span><br><span class="hljs-type">int</span> ischeck[<span class="hljs-number">10</span>] = &#123; <span class="hljs-number">0</span> &#125;;<span class="hljs-comment">//检查某一个数字是否使用</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m, __int64 ans)</span> &#123;<br><span class="hljs-keyword">if</span> (n == m - <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//因为调用时候是m+1，在上一次调用时m已经指向了n，然后这次调用是m+1,所以要判断是否指向最后一位，就应该看n是否为m-1</span><br>num[flag] = ans;<br>flag++;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">9</span>; i++) &#123;<span class="hljs-comment">//某一位有多少种数字</span><br><span class="hljs-keyword">if</span> (n != <span class="hljs-number">1</span> &amp;&amp; m == <span class="hljs-number">1</span> &amp;&amp; i == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">continue</span>;<span class="hljs-comment">//如果说该数不为一位数，一个指针m指向第一个数字,被m指向的数字为0</span><br><span class="hljs-comment">//那么就退出寻找0，在该位数寻找数字1，因为开头为0是没有意义的</span><br>&#125;<br><span class="hljs-keyword">if</span> (ischeck[i] == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//如果说数字i没有搜索过</span><br>ischeck[i] = <span class="hljs-number">1</span>;<span class="hljs-comment">//那么此时开始搜索，开始对1进行搜索</span><br>dfs(n, m + <span class="hljs-number">1</span>, ans * <span class="hljs-number">10</span> + i);<span class="hljs-comment">//再次调用该函数,将该数的指针指向下一位,然后数字就</span><br>ischeck[i] = <span class="hljs-number">0</span>;<span class="hljs-comment">//递归调用完后重置所有数据</span><br>&#125;<br>&#125;<br><span class="hljs-comment">//这个算法并不是让你一一进行比对，而是有一定顺序不会重复也不会漏数字去构造出复合题意的数据，并标记</span><br><span class="hljs-comment">//这是第几个数字</span><br><span class="hljs-comment">//我先枚举进行说明</span><br><span class="hljs-comment">//比方说3位数先判断0，因为开头为0,m==1，但是我们实际上没有搜索过0，所以 i = 1，开始在第一位搜索1，</span><br><span class="hljs-comment">//1没有搜索过，然后m+1进入下一位，此时我们的ans应该为1，代表构造的数为1</span><br><span class="hljs-comment">//然后m+1,进入下一位，因为是再一次调用该函数，在第二位上继续搜索数字，因为这是新调用的函数</span><br><span class="hljs-comment">//所以说i还是为0，代表第二位还是从0开始搜索</span><br><span class="hljs-comment">//因为最开始我们并没有搜索过0，而是直接退出，然后说明0的标记为0，此时我们搜索它，将其标记为1</span><br><span class="hljs-comment">//然后继续调用该函数进入下一位的搜索，此时的ans = 1*10+0 = 10,构造出来的第个数字为10</span><br><span class="hljs-comment">//所以说我们是这样构造的100，101，102... 120 121....这样</span><br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">int</span> n;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br>dfs(i, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<span class="hljs-comment">//从第1位数开始进行DFS搜索</span><br> <br>&#125;<br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n) != EOF) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%I64d\n&quot;</span>, num[n]);<br>&#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="recursion-递归-回溯"><a href="#recursion-递归-回溯" class="headerlink" title="recursion 递归 &amp;&amp; 回溯"></a>recursion 递归 &amp;&amp; 回溯</h3><h4 id="设计回溯算法"><a href="#设计回溯算法" class="headerlink" title="设计回溯算法"></a>设计回溯算法</h4><ol><li>将回溯问题抽象为一个树形结构</li><li>宽度一般用for循环，是要处理点的集合的大小</li><li>纵向用递归处理</li></ol><p>模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrading</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">if</span>(终止条件)&#123;<br>在叶子结点收集结果<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(遍历子节点的个数)&#123;<br>处理结点<br>递归<br>回溯<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>回溯三部曲：</p><ol><li>递归函数参数返回值</li><li>确定终止条件</li><li>单层递归的逻辑</li></ol><h4 id="设计递归函数"><a href="#设计递归函数" class="headerlink" title="设计递归函数"></a>设计递归函数</h4><p>理解递归的方法就是理解递归</p><p>设计递归函数的思路：</p><ul><li>子问题是一直递下去</li><li>边界条件才是归</li></ul><ol><li>确定base case，就是递归函数中唯一明确输入输出的基本情况（边界条件）。</li><li>分析并可视化</li><li>把复杂的问题简单化（解决子问题）</li><li>总结这个变化模式</li><li>将总结出来的变化模式和基本情况结合，写出代码</li><li>要有退出的条件，否则递归永无止境</li><li>解决递归问题就要坚信，子问题要更简单且可以解决</li><li>还要确定函数的参数表与返回类型</li></ol><h4 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h4><h5 id="dfs的思路"><a href="#dfs的思路" class="headerlink" title="dfs的思路"></a>dfs的思路</h5><ol><li>解决迷宫问题</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">function <span class="hljs-title function_">dfs</span><span class="hljs-params">(当前状态)</span>&#123;<br><span class="hljs-keyword">if</span>(当前状态 == 目的状态)&#123;<br>        ···<br>    &#125;<br>    <span class="hljs-keyword">for</span>(···寻找新状态)&#123;<br>        <span class="hljs-keyword">if</span>(状态合法)&#123;<br>            vis[访问该点]；<br>            dfs(新状态);<br>            ?是否需要恢复现场-&gt;vis[恢复访问]<br>        &#125; <br>    &#125;<br>    <span class="hljs-keyword">if</span>(找不到新状态)&#123;<br>        ···<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>解决穷举问题</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c">function <span class="hljs-title function_">dfs</span><span class="hljs-params">(当前状态, 一系列其他的状态量)</span>&#123;<br><span class="hljs-keyword">if</span>(当前状态 == 目的状态)&#123;<br>        ···<br>    &#125;<br>    <span class="hljs-keyword">for</span>(···寻找新状态)&#123;<br>        <span class="hljs-keyword">if</span>(状态合法)&#123;<br>            vis[访问该点]；<br>            dfs(新状态);<br>            ?是否需要恢复现场-&gt;vis[恢复访问]<br>        &#125; <br>    &#125;<br>    <span class="hljs-keyword">if</span>(找不到新状态)&#123;<br>        是否需要创建新规则？&#123;<br>            创建并对当前状态进行访问vis;<br>            继续搜索;<br>            恢复现场/恢复访问vis;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="动态规划-（递推）"><a href="#动态规划-（递推）" class="headerlink" title="动态规划 （递推）"></a>动态规划 （递推）</h3><p>一些个人理解：简单的动态规划问题就是递推+优化</p><ul><li>正推：递推公式</li><li>反推：搜索树dfs</li></ul><h4 id="暴力递归及记忆化优化（剪枝）"><a href="#暴力递归及记忆化优化（剪枝）" class="headerlink" title="暴力递归及记忆化优化（剪枝）"></a>暴力递归及记忆化优化（剪枝）</h4><h5 id="写一个暴力递归–第一步"><a href="#写一个暴力递归–第一步" class="headerlink" title="写一个暴力递归–第一步"></a>写一个暴力递归–第一步</h5><ol><li>确定base case</li><li>确定边界条件</li><li>尝试去写内容</li></ol><h5 id="可优化的dfs的优化思路（记忆化搜索——从顶向下的段优化）"><a href="#可优化的dfs的优化思路（记忆化搜索——从顶向下的段优化）" class="headerlink" title="可优化的dfs的优化思路（记忆化搜索——从顶向下的段优化）"></a>可优化的dfs的优化思路（记忆化搜索——从顶向下的段优化）</h5><p>–第二步</p><ol><li>一定要画出父子问题的树图出来</li><li>只有有重复解的时候才能优化暴力递归</li><li>如果每个解都不同，是不能优化暴力递归的</li><li>用一个可以装下全部情况的dp数组（一二三维都行）</li><li>全部初始化为-1</li><li>如果不是-1那么返回dp数组</li><li>代码后部分要保存dp的值</li></ol><p><strong>通过暴力递归来写dp状态转移：</strong> 暴力递归就是尝试</p><p>–第三步</p><ol><li>利用第二次写的优化dp1来填表</li><li>确认base case-&gt;填表</li><li>分析临界条件-&gt;填表</li><li>分析普遍条件-&gt;填表</li><li>根据表格分析状态转移（写递推）</li></ol><h4 id="一些题目"><a href="#一些题目" class="headerlink" title="一些题目"></a>一些题目</h4><h5 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h5><p><img src="/2023-12-05-11-02-35.png" alt="11"></p><p><strong>暴力递归解法：</strong><br><img src="/2023-12-05-11-03-51.png" alt="12"></p><p><strong>dp优化1：</strong><br>注意c语言是不能这样调用二维数组的，考虑放在全局，然后每次都mem<br><img src="/2023-12-05-11-05-15.png" alt="13"></p><p><strong>正推dp：</strong><br><img src="/2023-12-05-18-39-33.png" alt="141"><br><img src="/2023-12-05-18-38-47.png" alt="142"><br><img src="/2023-12-05-16-49-46.png" alt="143"></p><h5 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h5><p><img src="/2023-12-05-16-53-00.png" alt="21"></p><p><strong>暴力递归解法：</strong><br><img src="/2023-12-05-18-29-30.png" alt="22"></p><p><strong>dp优化1：</strong>（记忆化搜索）<br><img src="/2023-12-05-18-31-18.png" alt="231"></p><p><img src="/2023-12-05-18-32-34.png" alt="232"></p><p><strong>正推dp：</strong><br><img src="/2023-12-05-18-36-33.png" alt="241"><br><img src="/2023-12-05-18-37-24.png" alt="242"></p></font>]]></content>
    
    
    <categories>
      
      <category>C/CPP</category>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>c和指针</title>
    <link href="/2023/08/06/point%20on%20c/"/>
    <url>/2023/08/06/point%20on%20c/</url>
    
    <content type="html"><![CDATA[<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><ol><li><p>如果把指针理解为地址，房子理解为值，只要知道地址并且拥有钥匙就可以访问，那么就有如下思考：</p><ul><li><code>int *pi</code> 指向的是值，pi本身是地址，这是已知房子的地址（pi）并且拥有房子的钥匙（*）来访问值。</li><li><code>int const *pci</code>在这里<code>const</code>声明的是<code>*pci</code>那么就是已经指向了值，所以地址可以改变，但是值不可以改变。可以理解为：可以搬家，但是房子依旧不变（飞屋环游记？）</li><li><code>int *const pci</code>在这里<code>const</code>声明的是<code>pci</code>只是地址，没有指向值，所以是可以修改值，但是不可以修改地址。可以理解为：可以给家装修，但是不可以搬家。</li><li><code>int const *const cpci</code>这里是都不能变。</li></ul></li></ol><h2 id="链接属性（写项目可能用得到）"><a href="#链接属性（写项目可能用得到）" class="headerlink" title="链接属性（写项目可能用得到）"></a>链接属性（写项目可能用得到）</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ol><li><strong>external</strong>：无论声明多少次，在多个源文件中，永远指向同一个实体，主要是：<strong>函数</strong>、<strong>全局变量</strong>…</li><li><strong>internal</strong>：在不同源文件里声明是不同的实体（知道这个就行，是关键区分），一般来说除非特意声明，不会存在。</li><li><strong>none</strong>：没有链接属性（即上述二者的属性）。一般来说，不是external的就是none。</li></ol><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><ol><li><strong>static</strong>：把external链接属性的变量声明为internal（只对external的有效），<strong>只有基于external才有internal</strong>，使用方法<code>static &lt;类型名&gt; &lt;变量名&gt;</code>，如<code>static int i;</code>和<code>static void prime(n)</code>。</li><li><strong>extern</strong>：更多是用来一个提示的作用。</li><li>第一次声明确定了链接属性，那么在后续多次声明，后不会改变链接属性，除非特意声明。</li></ol><h3 id="存储类型"><a href="#存储类型" class="headerlink" title="存储类型"></a>存储类型</h3><ol><li>普通（静态）内存：关键字<code>static</code>，在代码块之外声明的变量都是<strong>静态变量</strong>，存储于静态内存中。每次运行之前创立，会始终存在，默认初始化为0，即全局变量。</li><li>运行时堆栈：关键字<code>auto</code>，在代码块中的变量都是<strong>自动变量</strong>，每次要用的时候都会重新创建，位置和值都有可能和上次调用不同。即局部变量。</li><li>硬件寄存器：关键字<code>register</code>，计算机不一定理睬。</li></ol><h3 id="关键字static"><a href="#关键字static" class="headerlink" title="关键字static"></a>关键字static</h3><ol><li>链接属性：对函数声明，或者对代码块之外的变量声明，都是改变链接属性。改成internal。</li><li>存储类型：对于代码块之内的变量声明，都是改变存储类型。改成静态变量。</li><li>综上，全局变量同时拥有external的链接属性（所有文件共用），和静态的存储类型（执行前创建）。</li></ol><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p><img src="/img/2023-09-19-13-21-07.png"></p><p><code>1&lt;&lt;bit_num</code> 意思是，把0000 0001向左移动bit_num位<br><code>b&amp;1</code>&lt;&#x3D;&gt;<code>b%2==1</code></p><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p><img src="/img/2023-09-19-13-34-07.png"></p><p>一些复合赋值符：<img src="/img/2023-09-19-13-39-45.png"></p><h4 id="EOF"><a href="#EOF" class="headerlink" title="EOF"></a>EOF</h4><p><img src="/img/2023-09-19-13-37-02.png"></p><h3 id="单目操作符"><a href="#单目操作符" class="headerlink" title="单目操作符"></a>单目操作符</h3><h4 id="和-！"><a href="#和-！" class="headerlink" title="~ 和 ！"></a>~ 和 ！</h4><p><img src="/img/2023-09-19-13-45-11.png"><br><img src="/img/2023-09-19-13-44-03.png"><br>思考：<code>~</code>是二进制取反，效果见上图,不同于<code>!</code></p><h4 id="和"><a href="#和" class="headerlink" title="* 和 &amp;"></a>* 和 &amp;</h4><p><img src="/img/2023-09-19-13-58-16.png"></p><h4 id="sizeof（细节要注意）和强制转化符"><a href="#sizeof（细节要注意）和强制转化符" class="headerlink" title="sizeof（细节要注意）和强制转化符"></a>sizeof（细节要注意）和强制转化符</h4><p><img src="/img/2023-09-19-14-01-22.png"></p><h4 id="和–"><a href="#和–" class="headerlink" title="++和–"></a>++和–</h4><p>记忆性的解释：<img src="/img/2023-09-19-14-18-47.png"><br>正真的解释：<img src="/img/2023-09-19-14-22-03.png"></p><h4 id="操作符"><a href="#操作符" class="headerlink" title=", 操作符"></a>, 操作符</h4><p><img src="/img/2023-09-20-13-57-50.png"></p><h4 id="下标访问操作符-和-间接访问表达式"><a href="#下标访问操作符-和-间接访问表达式" class="headerlink" title="下标访问操作符 和 间接访问表达式"></a>下标访问操作符 和 间接访问表达式</h4><p><img src="/img/2023-09-20-13-59-39.png"></p><h3 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h3><ol><li>左值是要有明确位置的变量不可以形如<code>a+25=...</code></li></ol><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p><img src="/img/2023-09-20-16-39-16.png"><br><img src="/img/2023-09-20-16-44-03.png"></p>]]></content>
    
    
    <categories>
      
      <category>C/CPP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>some notes in oj of XTU</title>
    <link href="/2023/08/06/the%20difficulties%20in%20oj/"/>
    <url>/2023/08/06/the%20difficulties%20in%20oj/</url>
    
    <content type="html"><![CDATA[<h2 id="题目汇总"><a href="#题目汇总" class="headerlink" title="题目汇总"></a>题目汇总</h2><ol><li>1270</li><li>1238</li></ol><h2 id="组合数的思路"><a href="#组合数的思路" class="headerlink" title="组合数的思路"></a>组合数的思路</h2><ol><li>先把<strong>每行</strong>首尾赋值成1</li><li>正下方（y-1）+右下方（x-1，y-1）</li><li>行数是从第二行开始，不然会空</li><li>代码体现：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">zuhe</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><span class="hljs-comment">//n是行数</span><br>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) C[i][<span class="hljs-number">0</span>]=C[i][i]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<span class="hljs-comment">//注意是从第二行开始</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            C[i][j]=(C[i<span class="hljs-number">-1</span>][j]+C[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>])%mo;<span class="hljs-comment">//一个递归的过程</span><br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>注意：上述代码的<strong>mo</strong>是应题目要求的除模，数字较小的时候可以忽略</li></ol><h2 id="分解质因数会用到的小技巧"><a href="#分解质因数会用到的小技巧" class="headerlink" title="分解质因数会用到的小技巧"></a>分解质因数会用到的小技巧</h2><h3 id="前缀和cnt-i-cnt-i-1-something"><a href="#前缀和cnt-i-cnt-i-1-something" class="headerlink" title="前缀和cnt[i]=cnt[i-1]+something;"></a>前缀和<code>cnt[i]=cnt[i-1]+something;</code></h3><h3 id="埃筛"><a href="#埃筛" class="headerlink" title="埃筛"></a>埃筛</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX=<span class="hljs-number">1e6</span>+<span class="hljs-number">5</span><br><span class="hljs-type">int</span> flag[MAX]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">void</span> <span class="hljs-title function_">prime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>    flag[<span class="hljs-number">0</span>]=flag[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-built_in">sqrt</span>(n);i++)&#123;<br>        <span class="hljs-keyword">if</span>(!flag[i])&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i*i;j&lt;=n;j+=i)&#123;<br>                flag[j]=<span class="hljs-number">1</span>; <span class="hljs-comment">// caution!!!!!!! is ** j ** !!!!!!!</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="用欧拉方程计算质因数的技巧"><a href="#用欧拉方程计算质因数的技巧" class="headerlink" title="用欧拉方程计算质因数的技巧"></a>用欧拉方程计算质因数的技巧</h2><p>目标：<img src="/img/2023-10-13-00-09-17.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-keyword">if</span>(!flag[i])&#123;<br>    <span class="hljs-keyword">while</span>(n%i==<span class="hljs-number">0</span>)&#123;<br>        n/=i;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C/CPP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>cs61a 3</title>
    <link href="/2023/08/04/py-cs61a-3/"/>
    <url>/2023/08/04/py-cs61a-3/</url>
    
    <content type="html"><![CDATA[<h3 id="Python的命名指南"><a href="#Python的命名指南" class="headerlink" title="Python的命名指南"></a>Python的命名指南</h3><ol><li>函数名称小写，用下划线分隔单词。鼓励使用描述性名称。  </li><li>函数名称通常呼应解释器应用于参数的操作（例如，print、add、square）或结果数量的名称（例如，max、abs、sum）。  </li><li>参数名称小写，用下划线分隔单词。优先选择单词名称。  </li><li>参数名称应唤起参数在函数中的角色，而不仅仅是允许的参数类型。  </li><li>单字母参数名称在其角色明显时是可接受的，但避免使用 “l”（小写的 L）、”O”（大写的 O）或 “I”（大写的 I）以避免与数字混淆。</li></ol><h3 id="对于函数的注释"><a href="#对于函数的注释" class="headerlink" title="对于函数的注释"></a>对于函数的注释</h3><ol><li>要用三引号”””内容”””，例如:<img src="/img/2023-08-04-20-15-29.png"><br>这样可以直接<code>help(函数名)</code>就能查阅该注释文档  </li><li>可以用’#’来注释，等同于c里面的’\\&#39;</li></ol><h3 id="对于默认值"><a href="#对于默认值" class="headerlink" title="对于默认值"></a>对于默认值</h3><p>py里面可以直接在函数里给出默认值，如下图的n,那么，如果在不改变该值的前提下调用这个函数，可以省略输入这个逗号后面的值，当然，如果想改变这个值那么就直接把想改变的值输入进去：<img src="/img/2023-08-04-20-22-46.png">  </p><h3 id="对于简单句——return-print"><a href="#对于简单句——return-print" class="headerlink" title="对于简单句——return &amp; print"></a>对于简单句——return &amp; print</h3><p>只用注意<strong>字符串</strong>：对于有’’的内容，比如’string’，return返回并输出’string’，print返回None并输出string。</p><h3 id="对于复合语句"><a href="#对于复合语句" class="headerlink" title="对于复合语句"></a>对于复合语句</h3><ol><li><p>缩进很重要，最好只用空格，不宜用tab</p></li><li><p>if - else 语句：</p> <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">if</span> &lt;expression&gt;:<br>    &lt;suite&gt;<br><span class="hljs-keyword">elif</span> &lt;expression&gt;:<br>    &lt;suite&gt;<br><span class="hljs-keyword">else</span>:<br>    &lt;suite&gt;<br></code></pre></td></tr></table></figure><ul><li>没有else if，直接就是<code>elif</code></li><li><code>elif</code>接条件</li><li>要冒号和缩进</li></ul></li><li><p>boolean assignment</p> <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">4</span> &lt; <span class="hljs-number">2</span><br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">5</span> &gt;= <span class="hljs-number">5</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">0</span> == -<span class="hljs-number">0</span><br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><ul><li><code>&gt;, &lt;, &gt;=, &lt;=, ==, !=</code>返回True或者False</li><li>注意第一个字母大写</li></ul></li><li><p>boolean operator</p> <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">True</span> <span class="hljs-keyword">and</span> <span class="hljs-literal">False</span><br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">True</span> <span class="hljs-keyword">or</span> <span class="hljs-literal">False</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">not</span> <span class="hljs-literal">False</span><br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><ul><li>在and 和  or 没有短路，即后面的值没有问题时，不会截断，并且返回最后一个数的数值，比如<code>True and 13</code>返回13;<code>False or 0</code>返回0。</li><li>很有趣，在and的时候，如果第一个是False，那么就会直接shortcut，返回Flase，比如1&#x2F;0是Error，但是在<code>False and 1/0</code>会直接返回False，如果是<code>True and 1/0</code>，则会计算1&#x2F;0，报错Error。</li><li>同理，在or的时候，如果第一个是True则直接返回True。</li></ul></li><li><p>while——尽量用for,py的while太奇怪了，会返回None。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">while</span> &lt;expression&gt;:<br>     &lt;suite&gt;<br></code></pre></td></tr></table></figure><ul><li>在py里的<code>while</code>语句，如果要强行停止使用<code>ctrl+c</code>。</li></ul></li></ol><p>&#x2F;&#x2F;学习进程：<br>&#x2F;&#x2F;textbook：1.5开始<br>&#x2F;&#x2F;hw卡住了，还在hw01<br>&#x2F;&#x2F;lecture-3还没开始</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
      <category>cs61a</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>把用vscode插件插入的图片传上hexo的方法</title>
    <link href="/2023/07/31/paste_image/"/>
    <url>/2023/07/31/paste_image/</url>
    
    <content type="html"><![CDATA[<h2 id="首先应该在vscode上面安装插件paste-image"><a href="#首先应该在vscode上面安装插件paste-image" class="headerlink" title="首先应该在vscode上面安装插件paste image"></a>首先应该在vscode上面安装插件paste image</h2><ol><li>直接ctrl+alt+v就可以把图片插入markdown里面，但是并不能上传到hexo博客里</li><li>用上述快捷键插入图片会生成 <code>![](xxx.png)</code> 的链接格式，并且直接在和md文件并列的文件夹里下载对应图片的png</li></ol><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>创立一个img文件夹在source下，例如我的博客存放路径是<code>/d/hexo/source/_posts</code>，那么就在source下创立一个和 _posts平行的文件夹img，路径为<code>/d/hexo/source/img</code>，同时把用快捷键生成的链接改成<code>![](/img/xxx.png) </code>即可。</p><p>至此问题解决。</p>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>nand to tetris unit 0</title>
    <link href="/2023/07/30/nand%20p%20I%20unit%200/"/>
    <url>/2023/07/30/nand%20p%20I%20unit%200/</url>
    
    <content type="html"><![CDATA[<h2 id="课程简介第一节课"><a href="#课程简介第一节课" class="headerlink" title="课程简介第一节课"></a>课程简介第一节课</h2><ol><li>letter –means single alphat</li><li>pixel –means picture element（像素！）</li><li>nand –与非门</li></ol><p><img src="/img/2023-07-31-15-00-05.png"></p><h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><p><img src="/img/2023-07-31-15-03-26-1.png"></p><h2 id="tool-project"><a href="#tool-project" class="headerlink" title="tool &amp; project"></a>tool &amp; project</h2><p><img src="/img/2023-07-31-15-22-15.png"></p>]]></content>
    
    
    <categories>
      
      <category>计组</category>
      
      <category>nand part I</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>nand to tetris unit 1</title>
    <link href="/2023/07/30/nand%20p%20I%20unit%201/"/>
    <url>/2023/07/30/nand%20p%20I%20unit%201/</url>
    
    <content type="html"><![CDATA[<p>&#x2F;&#x2F;注：HardwareSimulator ALU.tst</p><h2 id="unit-1-1-——-bool-fundamental-knowledge"><a href="#unit-1-1-——-bool-fundamental-knowledge" class="headerlink" title="unit 1.1 —— bool fundamental knowledge"></a>unit 1.1 —— bool fundamental knowledge</h2><h3 id="bool-1-0"><a href="#bool-1-0" class="headerlink" title="bool 1 &amp; 0"></a>bool 1 &amp; 0</h3><ol><li>AND 有0全0——‘&#x2F;\‘</li><li>OR 有1全1——‘\&#x2F;‘</li><li>NOT 非——横折</li></ol><h4 id="bool-functions"><a href="#bool-functions" class="headerlink" title="bool functions"></a>bool functions</h4><ol><li>Formula<br>f(x,y,z) &#x3D; (x AND y) OR (NOT(x) AND z)<br>处理方式 ——列真值表——Truth table<br><img src="/img/2023-07-31-15-35-42.png"></li></ol><h4 id="boolean-identities-运算"><a href="#boolean-identities-运算" class="headerlink" title="boolean identities(运算)"></a>boolean identities(运算)</h4><ol><li>交换律<br><img src="/img/2023-07-31-15-37-53.png">  </li><li>结合律<br><img src="/img/2023-07-31-15-38-23.png">  </li><li>分配律<br><img src="/img/2023-07-31-15-38-58.png">  </li><li>德摩根定律（非的运算）<br><img src="/img/2023-07-31-15-40-34.png"></li></ol><h4 id="algebra"><a href="#algebra" class="headerlink" title="algebra"></a>algebra</h4><p>   <img src="/img/2023-07-31-15-42-56.png"></p><h2 id="unit-1-2-——-Truth-Table-to-Boolean-Expression"><a href="#unit-1-2-——-Truth-Table-to-Boolean-Expression" class="headerlink" title="unit 1.2 —— Truth Table to Boolean Expression"></a>unit 1.2 —— Truth Table to Boolean Expression</h2><p>&#x2F;&#x2F;数电学了,可以回忆卡诺图</p><ol><li><p>结论1：<strong>所有布尔函数都能化简成为最简的与、或、非表达式</strong></p></li><li><p>nand function： <strong>NAND —— 或非门</strong>  </p><ul><li>(y NAND x) &#x3D; NOT(x AND y)</li><li>NOT(x) &#x3D; (x NAND x)</li><li>(x AND y) &#x3D; NOT(x NAND y)</li><li>NAND可以计算所有bool,以此来构建计算机</li></ul></li></ol><h2 id="unit-1-3-——-logic-gate"><a href="#unit-1-3-——-logic-gate" class="headerlink" title="unit 1.3 —— logic gate"></a>unit 1.3 —— logic gate</h2><h3 id="NAND–most-fundamental"><a href="#NAND–most-fundamental" class="headerlink" title="NAND–most fundamental"></a>NAND–most fundamental</h3><ol><li>NAND gate :<br> <img src="/img/2023-07-31-16-42-04.png"></li><li><strong>if (a&#x3D;&#x3D;1 and b&#x3D;&#x3D;1) then out&#x3D;0 else out&#x3D;1</strong></li><li>Truth table:<br> <img src="/img/2023-07-31-16-43-35.png">  </li><li>三种基础门： <img src="/img/2023-07-31-16-44-36.png"></li><li>a AND b AND c :<img src="/img/2023-07-31-16-57-49.png"></li><li>再回忆一下电路实现——并联、串联。</li></ol><h2 id="unit-1-4-——-hardware-description-language"><a href="#unit-1-4-——-hardware-description-language" class="headerlink" title="unit 1.4 —— hardware description language!!!!!!!!!!"></a>unit 1.4 —— hardware description language!!!!!!!!!!</h2><ol><li><p>Xor :<br><img src="/img/2023-07-31-17-15-04.png"></p></li><li><p>器件名称必须用官方正式名称，没有自由度</p></li><li><p>Xor用硬件描述语言来实现：<br><img src="/img/2023-07-31-17-25-02.png"></p></li><li><p>what can we say in HDL?  </p><ul><li>缺陷：要有良好的文件保存；要想出良好的描述性名称（包括硬件和输出线路）。</li><li>最后两点最重要，类似一个已经确定好形参（虽然这个说法在c语言不太好，但是在这里很恰当）的函数，然后还有默认a，in，b是输入，out是输出的说法。<br><img src="/img/2023-07-31-17-31-24.png"></li></ul></li></ol><h2 id="unit-1-5-——-hardware-simulation"><a href="#unit-1-5-——-hardware-simulation" class="headerlink" title="unit 1.5 —— hardware simulation"></a>unit 1.5 —— hardware simulation</h2><h3 id="simulation-options"><a href="#simulation-options" class="headerlink" title="simulation options"></a>simulation options</h3><pre><code class="hljs">- interactive//互动性  - script-based  - with/without output and compare files  </code></pre><h3 id="some-hardware-操作指南"><a href="#some-hardware-操作指南" class="headerlink" title="some hardware 操作指南"></a>some hardware 操作指南</h3><ol><li>hardware simulation 是tools里面的同名.bat文件，双击即可，但是前提是要安装好Java。（因为该软件是Java写的）  </li><li>可以在vscode上面加配件来写hdl文件</li><li>上面的小黄纸是用来添加.tst文件的，左上的蓝色小箭头&gt;是用于调试的，可以把右上角的Decimal右边的，可能是script也可能是out,也可能是compare都可以调用。</li><li>.cmp文件是别人写好的优良对应芯片的测试输出结果，用于和我们生成的out文件对比是否正确。</li></ol><h2 id="unit-1-6-——-Multi-bit-Buses"><a href="#unit-1-6-——-Multi-bit-Buses" class="headerlink" title="unit 1.6 —— Multi-bit Buses"></a>unit 1.6 —— Multi-bit Buses</h2><ol><li>bus是一种类似于数组的概念</li><li>是从0开始的下标：  <img src="/img/2023-08-02-16-57-41.png"></li><li>中间值不用另外声明： <img src="/img/2023-08-02-16-59-26.png"></li><li>没有进位的四位加法器:<img src="/img/2023-08-02-17-03-22.png"></li><li>如果有一个A[16] 的bus，那么A[0]是最右边（最低有效位），A[15]是最左边（最高有效位），和c相反</li></ol><h2 id="unit-1-7-——-project-overview"><a href="#unit-1-7-——-project-overview" class="headerlink" title="unit 1.7 —— project overview"></a>unit 1.7 —— project overview</h2><h3 id="elementary-logic-gates"><a href="#elementary-logic-gates" class="headerlink" title="elementary logic gates"></a>elementary logic gates</h3><ol><li>multiplexor(数据选择器)</li></ol><ul><li>结构、描述、真值表：<img src="/img/2023-08-05-14-54-49.png"></li></ul><ol start="2"><li>demultiplexor(多路分配器)</li></ol><ul><li>结构、描述、真值表：<img src="/img/2023-08-05-14-59-55.png"></li></ul><ol start="3"><li><p>二者结合在通讯网络中的应用</p><ul><li>图纸：<img src="/img/2023-08-05-15-03-22.png"></li></ul></li></ol><h3 id="16-bit-chips"><a href="#16-bit-chips" class="headerlink" title="16-bit chips"></a>16-bit chips</h3><ol><li><p>And16</p><ul><li>图纸和原理：<img src="/img/2023-08-05-15-08-38.png"></li></ul></li></ol><h3 id="multi-way-多路变体"><a href="#multi-way-多路变体" class="headerlink" title="multi-way 多路变体"></a>multi-way 多路变体</h3><ol><li>结构图和真值表：<img src="/img/2023-08-05-15-17-17.png"></li></ol><h2 id="一些帮助性的网站在官网project1的第一个最下面"><a href="#一些帮助性的网站在官网project1的第一个最下面" class="headerlink" title="一些帮助性的网站在官网project1的第一个最下面"></a>一些帮助性的网站在官网project1的第一个最下面</h2><h2 id="门路名称网址"><a href="#门路名称网址" class="headerlink" title="门路名称网址"></a>门路名称网址</h2><p><a href="http://nand2tetris-questions-and-answers-forum.52.s1.nabble.com/Projects-1-5-List-of-Built-In-Chips-td4028133.html">http://nand2tetris-questions-and-answers-forum.52.s1.nabble.com/Projects-1-5-List-of-Built-In-Chips-td4028133.html</a></p>]]></content>
    
    
    <categories>
      
      <category>计组</category>
      
      <category>nand part I</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>cs61a 1</title>
    <link href="/2023/07/30/py-cs61a-1/"/>
    <url>/2023/07/30/py-cs61a-1/</url>
    
    <content type="html"><![CDATA[<h2 id="lecture-part"><a href="#lecture-part" class="headerlink" title="lecture part"></a>lecture part</h2><h3 id="Numeric-expressions"><a href="#Numeric-expressions" class="headerlink" title="Numeric expressions"></a>Numeric expressions</h3><p>2020<br>2000 + 20<br>-1 + 2 + 3 + 4 * ((5 &#x2F;&#x2F; 6) + 7 * 8 * 9)</p><h3 id="Call-expressions"><a href="#Call-expressions" class="headerlink" title="Call expressions"></a>Call expressions</h3><p><strong>max(3, 4.5)</strong> a,b可以是任何值，并且max和min里面可以有无限数量的值<br><strong>pow(100, 2)</strong><br><strong>min(3, 4.5)</strong><br>pow(2, 100)<br><strong>max(1, -2, 3, -4)</strong>  </p><h3 id="Importing-and-arithmetic-with-call-expressions"><a href="#Importing-and-arithmetic-with-call-expressions" class="headerlink" title="Importing and arithmetic with call expressions"></a>Importing and arithmetic with call expressions</h3><p>from operator import add, mul &#x2F;&#x2F;重要的在py里引入两个函数————两个数相加or相乘<br><strong>add(1, 2)</strong><br><strong>mul(4, 6)</strong><br>mul(add(4, mul(4, 6)), add(3, 5))<br><strong>add(4, mul(9, mul(add(4, mul(4, 6)), add(3, 5))))</strong> &#x2F;&#x2F;函数可以嵌套使用<br>对于py里函数的解释：<br><img src="/img/2023-07-31-20-53-50.png"></p><h3 id="Objects"><a href="#Objects" class="headerlink" title="Objects"></a>Objects</h3><h3 id="Note-Download-from-http-composingprograms-com-shakespeare-txt"><a href="#Note-Download-from-http-composingprograms-com-shakespeare-txt" class="headerlink" title="Note: Download from http://composingprograms.com/shakespeare.txt"></a>Note: Download from <a href="http://composingprograms.com/shakespeare.txt">http://composingprograms.com/shakespeare.txt</a></h3><p><strong>shakes &#x3D; open(‘shakespeare.txt’)</strong> &#x2F;&#x2F;把shakes声明为打开文件操作<br>注释一下py打开url的新操作</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> urllib.request <span class="hljs-keyword">import</span> urlopen//用了这行的话可以直接urlopen(<span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-keyword">import</span> urllib.request<br>htmlcode=urllib.request.urlopen(<span class="hljs-string">&quot;http://www.baidu.com&quot;</span>).read()<br><span class="hljs-built_in">print</span>(htmlcode)<br></code></pre></td></tr></table></figure><p><strong>text &#x3D; shakes.read().split()</strong>&#x2F;&#x2F;把text声明为打开、读取、分割好了的文件<br><strong>len(text)</strong>&#x2F;&#x2F;求长度<br><strong>text[:25]</strong>&#x2F;&#x2F;cat前25个字符串<br><strong>text.count(‘the’)</strong>&#x2F;&#x2F;计数，注意是’’单引号<br>text.count(‘thou’)<br>text.count(‘you’)<br>text.count(‘forsooth’)<br>text.count(‘,’)  </p><h3 id="Sets"><a href="#Sets" class="headerlink" title="Sets"></a>Sets</h3><p><strong>words &#x3D; set(text)</strong>&#x2F;&#x2F;设置为一个字符集合，会删去重复的<br><strong>len(words)</strong>&#x2F;&#x2F;长度<br><strong>max(words)</strong> &#x2F;&#x2F;This line finds the maximum element in the words set. When applied to a set of strings, max() will return the “maximum” string based on 字母顺序. In this context, it will return the last word when the words are sorted in 字母顺序.<br><strong>max(words, key&#x3D;len)</strong>  &#x2F;&#x2F;This line finds the maximum element in the words set based <strong>on the length of each word</strong>. The <strong>key&#x3D;len</strong> argument is indicating that the comparison should be based on the length of the words rather than their 字母顺序. As a result, it will return the longest word in the set. </p><h3 id="Reversals"><a href="#Reversals" class="headerlink" title="Reversals"></a>Reversals</h3><p><strong>‘draw’[::-1]</strong>&#x2F;&#x2F;回文切换<br><strong>‘character’ in words &gt;&gt;&gt; True&#x2F;False</strong>&#x2F;&#x2F;判断是否在合集里<br><strong>{w for w in words if w &#x3D;&#x3D; w[::-1] and len(w)&gt;4}</strong>&#x2F;&#x2F;把w换成a都行，查找在字符集合words里的回文字符<br><strong>{w for w in words if w[::-1] in words and len(w) &#x3D;&#x3D; 4}</strong>&#x2F;&#x2F;都在words里出现过的<br><strong>{w for w in words if w[::-1] in words and len(w) &gt; 6}</strong>  </p><p><img src="/img/2023-07-31-23-25-00.png"></p><h2 id="capture-part-——-只有第一节有，和lecture一模一样，不用看，浪费时间"><a href="#capture-part-——-只有第一节有，和lecture一模一样，不用看，浪费时间" class="headerlink" title="capture part —— 只有第一节有，和lecture一模一样，不用看，浪费时间"></a>capture part —— 只有第一节有，和lecture一模一样，不用看，浪费时间</h2>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
      <category>cs61a</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>cs61a 2</title>
    <link href="/2023/07/30/py-cs61a-2/"/>
    <url>/2023/07/30/py-cs61a-2/</url>
    
    <content type="html"><![CDATA[<h2 id="Imports"><a href="#Imports" class="headerlink" title="Imports"></a>Imports</h2><p><strong>from math import pi</strong>&#x2F;&#x2F;引入math库里的pi<br>pi * 71 &#x2F; 223<br><strong>from math import sin</strong><br>sin(pi&#x2F;2)<br><strong>from math import sub, sqrt</strong>&#x2F;&#x2F;pow不用,sub是减法,sqrt开根<br>依旧是math库，替代&#x2F;和&#x2F;&#x2F;的：<img src="/img/2023-08-04-20-09-40.png">  </p><h2 id="pure-function"><a href="#pure-function" class="headerlink" title="pure function"></a>pure function</h2><p>Functions have some input (their arguments) and return some output (the result of applying them). </p><h2 id="some-built-in-functions"><a href="#some-built-in-functions" class="headerlink" title="some built_in functions"></a>some built_in functions</h2><ol><li><strong>abs()</strong> &#x2F;&#x2F;绝对值函数，是pure函数  </li><li><strong>print(,,,,)</strong> &#x2F;&#x2F;不是pure函数,输出print内的值,返回None，可以试试：<img src="/img/2023-08-04-19-09-13.png"></li></ol><h3 id="Assignment（伴有神奇的交换语句）"><a href="#Assignment（伴有神奇的交换语句）" class="headerlink" title="Assignment（伴有神奇的交换语句）"></a>Assignment（伴有神奇的交换语句）</h3><p>radius &#x3D; 10<br>2 * radius<br>area, circ &#x3D; pi * radius * radius, 2 * pi * radius&#x2F;&#x2F;很特殊的声明方式<br>radius &#x3D; 20&#x2F;&#x2F;不会记忆前面的内容，因此area不会改变<br><strong>奇妙的赋值语句：</strong><img src="/img/2023-08-04-18-59-58.png"></p><h3 id="Function-values"><a href="#Function-values" class="headerlink" title="Function values"></a>Function values</h3><p>max<br>max(3, 4)<br><strong>f &#x3D; max</strong>&#x2F;&#x2F;把f声明为max函数，可以执行max函数的功能<br><strong>f</strong><br><strong>f(3, 4)</strong><br>max &#x3D; 7&#x2F;&#x2F;把max当作变量赋值<br>f(3, 4)<br>f(3, max)<br>f &#x3D; 2  </p><h3 id="User-defined-functions"><a href="#User-defined-functions" class="headerlink" title="User-defined functions"></a>User-defined functions</h3><p>from operator import add, mul</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py"><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">square</span>(<span class="hljs-params">x</span>)://定义一个函数，在结尾加一个回车就定义成功了<br>    <span class="hljs-keyword">return</span> mul(x, x)<br><br></code></pre></td></tr></table></figure><p>直接 <code>square</code> 会显示在内存的位置</p><p>square(21)<br>square(add(2, 5))<br>square(square(3))</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">sum_squares</span>(<span class="hljs-params">x, y</span>):<br>    <span class="hljs-keyword">return</span> add(square(x), square(y))<br><br></code></pre></td></tr></table></figure><p>sum_squares(3, 4)<br>sum_squares(5, 12)</p><h3 id="area-function"><a href="#area-function" class="headerlink" title="area function"></a>area function</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">area</span>():<br>    <span class="hljs-keyword">return</span> pi * radius * radius<br><br></code></pre></td></tr></table></figure><p>area()<br>radius &#x3D; 20<br>area()<br>radius &#x3D; 10<br>area()</p><h3 id="Name-conflicts"><a href="#Name-conflicts" class="headerlink" title="Name conflicts"></a>Name conflicts</h3><p>def square(square):<br>    return mul(square, square)<br>square(4)</p><h2 id="environment-diagram"><a href="#environment-diagram" class="headerlink" title="environment diagram"></a>environment diagram</h2><ol><li><strong>debug || frame&#x2F; environment diagram</strong>：<a href="https://pythontutor.com/cp/composingprograms.html#mode=edit">https://pythontutor.com/cp/composingprograms.html#mode=edit</a> 说是画什么框架图，在我看来就是用来<strong>debug</strong>的</li><li>一个很好利用上述网站的例子（活用树状图）：<img src="/img/2023-08-04-14-48-33.png"></li></ol><h2 id="define-functions"><a href="#define-functions" class="headerlink" title="define functions"></a>define functions</h2><ol><li>格式：<img src="/img/2023-08-04-14-54-46.png"></li></ol>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
      <category>cs61a</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>the important cmd in git</title>
    <link href="/2023/07/29/git_learning/"/>
    <url>/2023/07/29/git_learning/</url>
    
    <content type="html"><![CDATA[<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://blog.csdn.net/qq_52596258/article/details/119643715">https://blog.csdn.net/qq_52596258/article/details/119643715</a></p><h2 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a>git config</h2><p>–global user.name&#x2F;email 设立<br>user.name&#x2F;email 查询<br>–list 查询</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol><li><strong>mkdir</strong> 文件夹当库  </li><li><strong>git init</strong> 初始化为库(里面会生成一个,git文件不要删)  </li><li><strong>touch(vim)</strong> xx.txt&#x2F;.c ……创建文件  </li><li><strong>:wq&#x2F;ZZ</strong> 保存并退出</li><li><strong>git status</strong> 查询状态</li><li><strong>git add</strong> xx.txt 添加到缓存区</li><li><strong>cat</strong> xx.txt 可以投射文件</li><li><strong>git commit -m</strong> “操作名(方便日后查日志)”</li><li>到这里就存好了！！！</li></ol><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><ol><li>默认已经修改了xx.txt文件</li><li><strong>git add</strong> xx.txt</li><li><strong>git commit -m “append GPL”</strong> 提交到版本库</li><li><strong>git log</strong>查看提交日志</li><li>要提交**git commit -m “XX”**后才能加修改</li></ol><h2 id="回到某个版本"><a href="#回到某个版本" class="headerlink" title="回到某个版本"></a>回到某个版本</h2><p>&#x2F;&#x2F; 学到了2.2累了</p><p>&#x2F;&#x2F;2023.07.30更新：太监了，懒得学了，浪费时间，学vim去了——end  </p>]]></content>
    
    
    <categories>
      
      <category>Cmd_learnig</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
