<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/09/18/to%20use%20vim/"/>
    <url>/2023/09/18/to%20use%20vim/</url>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="cmd的操作"><a href="#cmd的操作" class="headerlink" title="cmd的操作"></a>cmd的操作</h2><ol><li><code>:sp</code>打开窗口，可以打开多个</li><li><code>:qa</code>退出全部</li><li><code>:tabnew</code>打开缓冲区</li><li><code>^w</code>+<code>w</code>+<code>j/k</code>实现窗口间光标的移动（normal）</li></ol><h2 id="normal"><a href="#normal" class="headerlink" title="normal"></a>normal</h2><ol><li><code>w</code>前进到下一个单词的头部</li><li><code>b</code>后退到下一个单词的头部</li><li><code>e</code>到单词尾部（前进）</li><li></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/09/18/hello-world/"/>
    <url>/2023/09/18/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>binary multiplication</title>
    <link href="/2023/09/17/binary%20multiplication/"/>
    <url>/2023/09/17/binary%20multiplication/</url>
    
    <content type="html"><![CDATA[<h2 id="binary-addition-and-subtraction"><a href="#binary-addition-and-subtraction" class="headerlink" title="binary addition and subtraction"></a>binary addition and subtraction</h2><p>move to the nand p I unit 2</p><h2 id="binary-signed-multiplication"><a href="#binary-signed-multiplication" class="headerlink" title="binary signed multiplication"></a>binary signed multiplication</h2><p>tips: binary numbers are written with the<strong>MSB</strong>(Most-significant bit) in the left-most position; the <strong>LSB</strong>(Least-significant bit) is the furthest-right bit</p><ol><li>n-bits * n-bits &lt;&#x3D; 2*n-bits:<img src="/img/2023-09-17-14-15-20.png"></li><li>用补码计算二进制的时候，会把符号位扩充到八位：<img src="/img/2023-09-17-14-18-57.png"></li><li>计算过程的补位：<img src="/img/2023-09-17-14-33-36.png"></li><li>如果乘数的MSB或者说符号位是1，那么这一位乘出来的乘积需要减去：<img src="/img/2023-09-17-15-01-50.png">但是，减法即是取补码做加法：<img src="/img/2023-09-17-15-04-56.png">这里的补码是全部都要取反再+1，因为符号位在很前面</li></ol><h2 id="bianry-division"><a href="#bianry-division" class="headerlink" title="bianry division"></a>bianry division</h2><p>1. </p><h2 id="真值、机器数"><a href="#真值、机器数" class="headerlink" title="真值、机器数"></a>真值、机器数</h2><p><img src="/img/2023-09-17-21-35-13.png"></p><h2 id="符号、进位、溢出"><a href="#符号、进位、溢出" class="headerlink" title="符号、进位、溢出"></a>符号、进位、溢出</h2><p><img src="/img/2023-09-17-21-57-43.png"><br><img src="/img/2023-09-17-21-58-26.png"><br><img src="/img/2023-09-17-22-00-43.png"></p><h2 id="第一次作业须知"><a href="#第一次作业须知" class="headerlink" title="第一次作业须知"></a>第一次作业须知</h2><ol><li>[-Y]补&#x3D;[Y]补全部求反</li><li>求补码要注意原码是正数还是负数</li><li><img src="/img/2023-09-17-22-45-09.png"></li></ol>]]></content>
    
    
    <categories>
      
      <category>计组</category>
      
      <category>binary computing</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>to build a own chatgpt</title>
    <link href="/2023/09/12/how%20to%20build%20up%20a%20own%20ChatGPT/"/>
    <url>/2023/09/12/how%20to%20build%20up%20a%20own%20ChatGPT/</url>
    
    <content type="html"><![CDATA[<h2 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h2><ol><li>apikey</li><li>服务器</li></ol>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数学自救指南</title>
    <link href="/2023/09/12/proof%20of%20math/"/>
    <url>/2023/09/12/proof%20of%20math/</url>
    
    <content type="html"><![CDATA[<h2 id="看证明的思考"><a href="#看证明的思考" class="headerlink" title="看证明的思考"></a>看证明的思考</h2><ol><li>策略：思路</li><li>技术：都会的基础方法</li><li>技巧：很巧妙的方法，关键性的一步</li></ol>]]></content>
    
    
    <categories>
      
      <category>math</category>
      
      <category>proof</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>nand to tetris unit 2</title>
    <link href="/2023/09/12/nand%20p%20I%20unit%202/"/>
    <url>/2023/09/12/nand%20p%20I%20unit%202/</url>
    
    <content type="html"><![CDATA[<h2 id="binary-addtion"><a href="#binary-addtion" class="headerlink" title="binary addtion"></a>binary addtion</h2><h3 id="half-adder-and-full-adder"><a href="#half-adder-and-full-adder" class="headerlink" title="half adder and full adder"></a>half adder and full adder</h3><ol><li>distinction:<ul><li>half one is 2 bits num ,but full one is 3 bits num</li><li>when two 16-bit num add,they may contribute to the caryy,if only use half adder,we cannot get right result,because it cannot add the carry with the two 1-bit num.</li></ul></li></ol><h3 id="16-bit-adder"><a href="#16-bit-adder" class="headerlink" title="16-bit adder"></a>16-bit adder</h3><ol><li>structure:<ul><li>it can be built by 16 full adders or 15 full adders with just 1 half adder in the most left place.</li><li><img src="/img/2023-09-12-11-31-09.png"></li></ul></li></ol><h2 id="binary-division"><a href="#binary-division" class="headerlink" title="binary division"></a>binary division</h2><h3 id="negative-numbers"><a href="#negative-numbers" class="headerlink" title="negative numbers"></a>negative numbers</h3><ol><li><p>complement: replace -x (b) by 2^n - x (b):<img src="/img/2023-09-12-19-35-29.png"></p><ul><li>positive num:0<del>2^(n-1)-1(b) the above is 0</del>7 and 0000~0111</li><li>negative num:-1<del>-2^(n-1) the above is -1</del>-8 and 1111~1000</li></ul></li></ol><h3 id="achieve-the-division"><a href="#achieve-the-division" class="headerlink" title="achieve the division"></a>achieve the division</h3><p><img src="/img/2023-09-12-19-41-51.png"></p><ol><li>representation: both the two num(-x &amp; 2^n-x) , their results of mol 2 is same. Like,-3 and 13(4-bits)</li></ol><ul><li>tip: modulo 模运算</li></ul><h3 id="反码和补码原理"><a href="#反码和补码原理" class="headerlink" title="反码和补码原理"></a>反码和补码原理</h3><p><img src="/img/2023-09-12-19-51-23.png"></p><ol><li><p>以4bits为例子，2^n -1是1111，再-x，等价于求反，最后再+1，那么就是2^n - x的实现了。</p></li><li><p>那么在硬件里怎么做到快速的+1，要分成两种情况讨论，最右边为0和最右边为1</p><ul><li>先讨论最右边为0，直接翻转变成1就行</li><li>最右边为1，则一直翻转成0，直到碰到第一个0，把它翻转为1，然后停止。</li></ul></li></ol><h2 id="对于补码反码逻辑关系的思考-significant"><a href="#对于补码反码逻辑关系的思考-significant" class="headerlink" title="对于补码反码逻辑关系的思考(significant)"></a>对于补码反码逻辑关系的思考(significant)</h2><p>一个MSB或符号位为1的的binary，比如<strong>11011101</strong>，可以确定是一个负数，然后它的补码是<strong>00100011</strong>即35，因此可以确定<strong>11011101</strong>是-35。<br>in chinese:<img src="/img/2023-09-17-15-37-52.png"></p><h2 id="ALU-arithmetic-logic-unit-—-算术逻辑单元"><a href="#ALU-arithmetic-logic-unit-—-算术逻辑单元" class="headerlink" title="ALU(arithmetic logic unit)—-算术逻辑单元"></a>ALU(arithmetic logic unit)—-算术逻辑单元</h2><ol><li>what is ALU?<img src="/img/2023-09-12-20-02-09.png"></li></ol>]]></content>
    
    
    <categories>
      
      <category>计组</category>
      
      <category>nand part I</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>the replace of some easy words</title>
    <link href="/2023/09/07/vocabulary/"/>
    <url>/2023/09/07/vocabulary/</url>
    
    <content type="html"><![CDATA[<h2 id="as-the-title"><a href="#as-the-title" class="headerlink" title="as the title"></a>as the title</h2><ol><li>stride – development</li><li>fulfill – achieve (dream) &#x2F;履行</li><li>console – comfort</li><li>liability – responsibility</li><li>conquer – overcome</li><li>competent – qualified</li><li>inhabitant – resident</li><li>render – cause</li><li>halt – stop</li></ol>]]></content>
    
    
    <categories>
      
      <category>English</category>
      
      <category>vocabulary</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>宝可梦紫攻略</title>
    <link href="/2023/08/08/pokemon/"/>
    <url>/2023/08/08/pokemon/</url>
    
    <content type="html"><![CDATA[<h2 id="各属性主力以及培养"><a href="#各属性主力以及培养" class="headerlink" title="各属性主力以及培养"></a>各属性主力以及培养</h2><p>收集：炭小侍、小火龙</p><ol><li><p>水：涌跃鸭</p><ul><li>进化成狂狼舞鸭有530种族值</li></ul></li><li><p>火：卡迪狗</p><ul><li>39级之后在火之石进化，关键是学神速</li><li>种族值555</li></ul></li><li><p>草：兰螳花——打水岩石地面</p><ul><li>兰：唱反调（特性）带贝壳、绿叶风暴、终极吸取、青草场地、光合作用</li></ul></li><li><p>妖精：玛力露丽 &amp;&amp; 仙子伊布</p><ul><li>玛力露丽：嬉闹（已学）、水流裂破、鼓腹</li><li>仙子伊布：亲密度&#x2F;友好度+妖精系招式————假哭、冥想、破坏死光</li></ul></li><li><p>一般系：猫老大</p><ul><li>铁壁、剑舞、铁头</li></ul></li><li><p>幽灵：耿鬼&#x2F;弃世猴</p><ul><li>暂无</li></ul></li><li><p>格斗：路卡利欧</p><ul><li>固执、剑舞神速&#x2F;子弹拳近身战</li><li><a href="https://jingyan.baidu.com/article/e6c8503c4dc783a44e1a1807.html">https://jingyan.baidu.com/article/e6c8503c4dc783a44e1a1807.html</a></li></ul></li><li><p>超能：呆呆王</p><ul><li>瞬间遗忘、诡计、辅助力量</li></ul></li><li><p>恶钢：仆刀将军</p><ul><li>铁壁、刺耳声、移花接木、金属爆炸</li></ul></li><li><p>龙：快龙&#x2F;路咬烈鲨</p></li><li><p>电：电蛙</p><ul><li>节拍器</li></ul></li><li><p>毒：毒藻龙</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
      <category>pokemon</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>学到的算法</title>
    <link href="/2023/08/06/Algorithm/"/>
    <url>/2023/08/06/Algorithm/</url>
    
    <content type="html"><![CDATA[<h2 id="快速幂（后续再补充）"><a href="#快速幂（后续再补充）" class="headerlink" title="快速幂（后续再补充）"></a>快速幂（后续再补充）</h2><h2 id="埃式筛选（后续再补充）"><a href="#埃式筛选（后续再补充）" class="headerlink" title="埃式筛选（后续再补充）"></a>埃式筛选（后续再补充）</h2><h2 id="组合数（后续再补充）"><a href="#组合数（后续再补充）" class="headerlink" title="组合数（后续再补充）"></a>组合数（后续再补充）</h2><h2 id="dfs（depth-first-search）"><a href="#dfs（depth-first-search）" class="headerlink" title="dfs（depth first search）"></a>dfs（depth first search）</h2><p><img src="/img/2023-08-25-22-41-07.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br>__int64 num[<span class="hljs-number">8877711</span>];<br><span class="hljs-type">int</span> flag = <span class="hljs-number">1</span>;<span class="hljs-comment">//判断满足题意的某个数的序号</span><br><span class="hljs-type">int</span> ischeck[<span class="hljs-number">10</span>] = &#123; <span class="hljs-number">0</span> &#125;;<span class="hljs-comment">//检查某一个数字是否使用</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m, __int64 ans)</span> &#123;<br><span class="hljs-keyword">if</span> (n == m - <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//因为调用时候是m+1，在上一次调用时m已经指向了n，然后这次调用是m+1,所以要判断是否指向最后一位，就应该看n是否为m-1</span><br>num[flag] = ans;<br>flag++;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">9</span>; i++) &#123;<span class="hljs-comment">//某一位有多少种数字</span><br><span class="hljs-keyword">if</span> (n != <span class="hljs-number">1</span> &amp;&amp; m == <span class="hljs-number">1</span> &amp;&amp; i == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">continue</span>;<span class="hljs-comment">//如果说该数不为一位数，一个指针m指向第一个数字,被m指向的数字为0</span><br><span class="hljs-comment">//那么就退出寻找0，在该位数寻找数字1，因为开头为0是没有意义的</span><br>&#125;<br><span class="hljs-keyword">if</span> (ischeck[i] == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//如果说数字i没有搜索过</span><br>ischeck[i] = <span class="hljs-number">1</span>;<span class="hljs-comment">//那么此时开始搜索，开始对1进行搜索</span><br>dfs(n, m + <span class="hljs-number">1</span>, ans * <span class="hljs-number">10</span> + i);<span class="hljs-comment">//再次调用该函数,将该数的指针指向下一位,然后数字就</span><br>ischeck[i] = <span class="hljs-number">0</span>;<span class="hljs-comment">//递归调用完后重置所有数据</span><br>&#125;<br>&#125;<br><span class="hljs-comment">//这个算法并不是让你一一进行比对，而是有一定顺序不会重复也不会漏数字去构造出复合题意的数据，并标记</span><br><span class="hljs-comment">//这是第几个数字</span><br><span class="hljs-comment">//我先枚举进行说明</span><br><span class="hljs-comment">//比方说3位数先判断0，因为开头为0,m==1，但是我们实际上没有搜索过0，所以 i = 1，开始在第一位搜索1，</span><br><span class="hljs-comment">//1没有搜索过，然后m+1进入下一位，此时我们的ans应该为1，代表构造的数为1</span><br><span class="hljs-comment">//然后m+1,进入下一位，因为是再一次调用该函数，在第二位上继续搜索数字，因为这是新调用的函数</span><br><span class="hljs-comment">//所以说i还是为0，代表第二位还是从0开始搜索</span><br><span class="hljs-comment">//因为最开始我们并没有搜索过0，而是直接退出，然后说明0的标记为0，此时我们搜索它，将其标记为1</span><br><span class="hljs-comment">//然后继续调用该函数进入下一位的搜索，此时的ans = 1*10+0 = 10,构造出来的第个数字为10</span><br><span class="hljs-comment">//所以说我们是这样构造的100，101，102... 120 121....这样</span><br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">int</span> n;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br>dfs(i, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<span class="hljs-comment">//从第1位数开始进行DFS搜索</span><br> <br>&#125;<br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n) != EOF) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%I64d\n&quot;</span>, num[n]);<br>&#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="dfs的思路"><a href="#dfs的思路" class="headerlink" title="dfs的思路"></a>dfs的思路</h3><ol><li>解决迷宫问题</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">function <span class="hljs-title function_">dfs</span><span class="hljs-params">(当前状态)</span>&#123;<br><span class="hljs-keyword">if</span>(当前状态 == 目的状态)&#123;<br>        ···<br>    &#125;<br>    <span class="hljs-keyword">for</span>(···寻找新状态)&#123;<br>        <span class="hljs-keyword">if</span>(状态合法)&#123;<br>            vis[访问该点]；<br>            dfs(新状态);<br>            ?是否需要恢复现场-&gt;vis[恢复访问]<br>        &#125; <br>    &#125;<br>    <span class="hljs-keyword">if</span>(找不到新状态)&#123;<br>        ···<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>解决穷举问题</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c">function <span class="hljs-title function_">dfs</span><span class="hljs-params">(当前状态, 一系列其他的状态量)</span>&#123;<br><span class="hljs-keyword">if</span>(当前状态 == 目的状态)&#123;<br>        ···<br>    &#125;<br>    <span class="hljs-keyword">for</span>(···寻找新状态)&#123;<br>        <span class="hljs-keyword">if</span>(状态合法)&#123;<br>            vis[访问该点]；<br>            dfs(新状态);<br>            ?是否需要恢复现场-&gt;vis[恢复访问]<br>        &#125; <br>    &#125;<br>    <span class="hljs-keyword">if</span>(找不到新状态)&#123;<br>        是否需要创建新规则？&#123;<br>            创建并对当前状态进行访问vis;<br>            继续搜索;<br>            恢复现场/恢复访问vis;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h3><h2 id="binary-search"><a href="#binary-search" class="headerlink" title="binary search"></a>binary search</h2><ol><li>normally, to avoid i+j over the scale of <code>int</code>,we do this: <code>int m = i+(j-i)/2</code></li><li></li></ol>]]></content>
    
    
    <categories>
      
      <category>C/CPP</category>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>c和指针</title>
    <link href="/2023/08/06/point%20on%20c/"/>
    <url>/2023/08/06/point%20on%20c/</url>
    
    <content type="html"><![CDATA[<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><ol><li><p>如果把指针理解为地址，房子理解为值，只要知道地址并且拥有钥匙就可以访问，那么就有如下思考：</p><ul><li><code>int *pi</code> 指向的是值，pi本身是地址，这是已知房子的地址（pi）并且拥有房子的钥匙（*）来访问值。</li><li><code>int const *pci</code>在这里<code>const</code>声明的是<code>*pci</code>那么就是已经指向了值，所以地址可以改变，但是值不可以改变。可以理解为：可以搬家，但是房子依旧不变（飞屋环游记？）</li><li><code>int *const pci</code>在这里<code>const</code>声明的是<code>pci</code>只是地址，没有指向值，所以是可以修改值，但是不可以修改地址。可以理解为：可以给家装修，但是不可以搬家。</li><li><code>int const *const cpci</code>这里是都不能变。</li></ul></li></ol><h2 id="链接属性（写项目可能用得到）"><a href="#链接属性（写项目可能用得到）" class="headerlink" title="链接属性（写项目可能用得到）"></a>链接属性（写项目可能用得到）</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ol><li><strong>external</strong>：无论声明多少次，在多个源文件中，永远指向同一个实体，主要是：<strong>函数</strong>、<strong>全局变量</strong>…</li><li><strong>internal</strong>：在不同源文件里声明是不同的实体（知道这个就行，是关键区分），一般来说除非特意声明，不会存在。</li><li><strong>none</strong>：没有链接属性（即上述二者的属性）。一般来说，不是external的就是none。</li></ol><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><ol><li><strong>static</strong>：把external链接属性的变量声明为internal（只对external的有效），<strong>只有基于external才有internal</strong>，使用方法<code>static &lt;类型名&gt; &lt;变量名&gt;</code>，如<code>static int i;</code>和<code>static void prime(n)</code>。</li><li><strong>extern</strong>：更多是用来一个提示的作用。</li><li>第一次声明确定了链接属性，那么在后续多次声明，后不会改变链接属性，除非特意声明。</li></ol><h3 id="存储类型"><a href="#存储类型" class="headerlink" title="存储类型"></a>存储类型</h3><ol><li>普通（静态）内存：关键字<code>static</code>，在代码块之外声明的变量都是<strong>静态变量</strong>，存储于静态内存中。每次运行之前创立，会始终存在，默认初始化为0，即全局变量。</li><li>运行时堆栈：关键字<code>auto</code>，在代码块中的变量都是<strong>自动变量</strong>，每次要用的时候都会重新创建，位置和值都有可能和上次调用不同。即局部变量。</li><li>硬件寄存器：关键字<code>register</code>，计算机不一定理睬。</li></ol><h3 id="关键字static"><a href="#关键字static" class="headerlink" title="关键字static"></a>关键字static</h3><ol><li>链接属性：对函数声明，或者对代码块之外的变量声明，都是改变链接属性。改成internal。</li><li>存储类型：对于代码块之内的变量声明，都是改变存储类型。改成静态变量。</li><li>综上，全局变量同时拥有external的链接属性（所有文件共用），和静态的存储类型（执行前创建）。</li></ol>]]></content>
    
    
    <categories>
      
      <category>C/CPP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>c和指针</title>
    <link href="/2023/08/06/the%20difficulties%20in%20oj/"/>
    <url>/2023/08/06/the%20difficulties%20in%20oj/</url>
    
    <content type="html"><![CDATA[<h2 id="题目汇总"><a href="#题目汇总" class="headerlink" title="题目汇总"></a>题目汇总</h2><ol><li>1270</li><li>1238</li></ol><h2 id="组合数的思路"><a href="#组合数的思路" class="headerlink" title="组合数的思路"></a>组合数的思路</h2><ol><li>先把<strong>每行</strong>首尾赋值成1</li><li>正下方（y-1）+右下方（x-1，y-1）</li><li>行数是从第二行开始，不然会空</li><li>代码体现：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">zuhe</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><span class="hljs-comment">//n是行数</span><br>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) C[i][<span class="hljs-number">0</span>]=C[i][i]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<span class="hljs-comment">//注意是从第二行开始</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            C[i][j]=(C[i<span class="hljs-number">-1</span>][j]+C[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>])%mo;<span class="hljs-comment">//一个递归的过程</span><br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>注意：上述代码的<strong>mo</strong>是应题目要求的除模，数字较小的时候可以忽略</li></ol>]]></content>
    
    
    <categories>
      
      <category>C/CPP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>cs61a 3</title>
    <link href="/2023/08/04/py-cs61a-3/"/>
    <url>/2023/08/04/py-cs61a-3/</url>
    
    <content type="html"><![CDATA[<h3 id="Python的命名指南"><a href="#Python的命名指南" class="headerlink" title="Python的命名指南"></a>Python的命名指南</h3><ol><li>函数名称小写，用下划线分隔单词。鼓励使用描述性名称。  </li><li>函数名称通常呼应解释器应用于参数的操作（例如，print、add、square）或结果数量的名称（例如，max、abs、sum）。  </li><li>参数名称小写，用下划线分隔单词。优先选择单词名称。  </li><li>参数名称应唤起参数在函数中的角色，而不仅仅是允许的参数类型。  </li><li>单字母参数名称在其角色明显时是可接受的，但避免使用 “l”（小写的 L）、”O”（大写的 O）或 “I”（大写的 I）以避免与数字混淆。</li></ol><h3 id="对于函数的注释"><a href="#对于函数的注释" class="headerlink" title="对于函数的注释"></a>对于函数的注释</h3><ol><li>要用三引号”””内容”””，例如:<img src="/img/2023-08-04-20-15-29.png"><br>这样可以直接<code>help(函数名)</code>就能查阅该注释文档  </li><li>可以用’#’来注释，等同于c里面的’\\&#39;</li></ol><h3 id="对于默认值"><a href="#对于默认值" class="headerlink" title="对于默认值"></a>对于默认值</h3><p>py里面可以直接在函数里给出默认值，如下图的n,那么，如果在不改变该值的前提下调用这个函数，可以省略输入这个逗号后面的值，当然，如果想改变这个值那么就直接把想改变的值输入进去：<img src="/img/2023-08-04-20-22-46.png">  </p><h3 id="对于简单句——return-print"><a href="#对于简单句——return-print" class="headerlink" title="对于简单句——return &amp; print"></a>对于简单句——return &amp; print</h3><p>只用注意<strong>字符串</strong>：对于有’’的内容，比如’string’，return返回并输出’string’，print返回None并输出string。</p><h3 id="对于复合语句"><a href="#对于复合语句" class="headerlink" title="对于复合语句"></a>对于复合语句</h3><ol><li><p>缩进很重要，最好只用空格，不宜用tab</p></li><li><p>if - else 语句：</p> <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">if</span> &lt;expression&gt;:<br>    &lt;suite&gt;<br><span class="hljs-keyword">elif</span> &lt;expression&gt;:<br>    &lt;suite&gt;<br><span class="hljs-keyword">else</span>:<br>    &lt;suite&gt;<br></code></pre></td></tr></table></figure><ul><li>没有else if，直接就是<code>elif</code></li><li><code>elif</code>接条件</li><li>要冒号和缩进</li></ul></li><li><p>boolean assignment</p> <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">4</span> &lt; <span class="hljs-number">2</span><br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">5</span> &gt;= <span class="hljs-number">5</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">0</span> == -<span class="hljs-number">0</span><br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><ul><li><code>&gt;, &lt;, &gt;=, &lt;=, ==, !=</code>返回True或者False</li><li>注意第一个字母大写</li></ul></li><li><p>boolean operator</p> <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">True</span> <span class="hljs-keyword">and</span> <span class="hljs-literal">False</span><br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">True</span> <span class="hljs-keyword">or</span> <span class="hljs-literal">False</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">not</span> <span class="hljs-literal">False</span><br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><ul><li>在and 和  or 没有短路，即后面的值没有问题时，不会截断，并且返回最后一个数的数值，比如<code>True and 13</code>返回13;<code>False or 0</code>返回0。</li><li>很有趣，在and的时候，如果第一个是False，那么就会直接shortcut，返回Flase，比如1&#x2F;0是Error，但是在<code>False and 1/0</code>会直接返回False，如果是<code>True and 1/0</code>，则会计算1&#x2F;0，报错Error。</li><li>同理，在or的时候，如果第一个是True则直接返回True。</li></ul></li><li><p>while——尽量用for,py的while太奇怪了，会返回None。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">while</span> &lt;expression&gt;:<br>     &lt;suite&gt;<br></code></pre></td></tr></table></figure><ul><li>在py里的<code>while</code>语句，如果要强行停止使用<code>ctrl+c</code>。</li></ul></li></ol><p>&#x2F;&#x2F;学习进程：<br>&#x2F;&#x2F;textbook：1.5开始<br>&#x2F;&#x2F;hw卡住了，还在hw01<br>&#x2F;&#x2F;lecture-3还没开始</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
      <category>cs61a</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>把用vscode插件插入的图片传上hexo的方法</title>
    <link href="/2023/07/31/paste_image/"/>
    <url>/2023/07/31/paste_image/</url>
    
    <content type="html"><![CDATA[<h2 id="首先应该在vscode上面安装插件paste-image"><a href="#首先应该在vscode上面安装插件paste-image" class="headerlink" title="首先应该在vscode上面安装插件paste image"></a>首先应该在vscode上面安装插件paste image</h2><ol><li>直接ctrl+alt+v就可以把图片插入markdown里面，但是并不能上传到hexo博客里</li><li>用上述快捷键插入图片会生成 <code>![](xxx.png)</code> 的链接格式，并且直接在和md文件并列的文件夹里下载对应图片的png</li></ol><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>创立一个img文件夹在source下，例如我的博客存放路径是<code>/d/hexo/source/_posts</code>，那么就在source下创立一个和 _posts平行的文件夹img，路径为<code>/d/hexo/source/img</code>，同时把用快捷键生成的链接改成<code>![](/img/xxx.png) </code>即可。</p><p>至此问题解决。</p>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>nand to tetris unit 0</title>
    <link href="/2023/07/30/nand%20p%20I%20unit%200/"/>
    <url>/2023/07/30/nand%20p%20I%20unit%200/</url>
    
    <content type="html"><![CDATA[<h2 id="课程简介第一节课"><a href="#课程简介第一节课" class="headerlink" title="课程简介第一节课"></a>课程简介第一节课</h2><ol><li>letter –means single alphat</li><li>pixel –means picture element（像素！）</li><li>nand –与非门</li></ol><p><img src="/img/2023-07-31-15-00-05.png"></p><h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><p><img src="/img/2023-07-31-15-03-26-1.png"></p><h2 id="tool-project"><a href="#tool-project" class="headerlink" title="tool &amp; project"></a>tool &amp; project</h2><p><img src="/img/2023-07-31-15-22-15.png"></p>]]></content>
    
    
    <categories>
      
      <category>计组</category>
      
      <category>nand part I</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>nand to tetris unit 1</title>
    <link href="/2023/07/30/nand%20p%20I%20unit%201/"/>
    <url>/2023/07/30/nand%20p%20I%20unit%201/</url>
    
    <content type="html"><![CDATA[<p>&#x2F;&#x2F;注：HardwareSimulator ALU.tst</p><h2 id="unit-1-1-——-bool-fundamental-knowledge"><a href="#unit-1-1-——-bool-fundamental-knowledge" class="headerlink" title="unit 1.1 —— bool fundamental knowledge"></a>unit 1.1 —— bool fundamental knowledge</h2><h3 id="bool-1-0"><a href="#bool-1-0" class="headerlink" title="bool 1 &amp; 0"></a>bool 1 &amp; 0</h3><ol><li>AND 有0全0——‘&#x2F;\‘</li><li>OR 有1全1——‘\&#x2F;‘</li><li>NOT 非——横折</li></ol><h4 id="bool-functions"><a href="#bool-functions" class="headerlink" title="bool functions"></a>bool functions</h4><ol><li>Formula<br>f(x,y,z) &#x3D; (x AND y) OR (NOT(x) AND z)<br>处理方式 ——列真值表——Truth table<br><img src="/img/2023-07-31-15-35-42.png"></li></ol><h4 id="boolean-identities-运算"><a href="#boolean-identities-运算" class="headerlink" title="boolean identities(运算)"></a>boolean identities(运算)</h4><ol><li>交换律<br><img src="/img/2023-07-31-15-37-53.png">  </li><li>结合律<br><img src="/img/2023-07-31-15-38-23.png">  </li><li>分配律<br><img src="/img/2023-07-31-15-38-58.png">  </li><li>德摩根定律（非的运算）<br><img src="/img/2023-07-31-15-40-34.png"></li></ol><h4 id="algebra"><a href="#algebra" class="headerlink" title="algebra"></a>algebra</h4><p>   <img src="/img/2023-07-31-15-42-56.png"></p><h2 id="unit-1-2-——-Truth-Table-to-Boolean-Expression"><a href="#unit-1-2-——-Truth-Table-to-Boolean-Expression" class="headerlink" title="unit 1.2 —— Truth Table to Boolean Expression"></a>unit 1.2 —— Truth Table to Boolean Expression</h2><p>&#x2F;&#x2F;数电学了,可以回忆卡诺图</p><ol><li><p>结论1：<strong>所有布尔函数都能化简成为最简的与、或、非表达式</strong></p></li><li><p>nand function： <strong>NAND —— 或非门</strong>  </p><ul><li>(y NAND x) &#x3D; NOT(x AND y)</li><li>NOT(x) &#x3D; (x NAND x)</li><li>(x AND y) &#x3D; NOT(x NAND y)</li><li>NAND可以计算所有bool,以此来构建计算机</li></ul></li></ol><h2 id="unit-1-3-——-logic-gate"><a href="#unit-1-3-——-logic-gate" class="headerlink" title="unit 1.3 —— logic gate"></a>unit 1.3 —— logic gate</h2><h3 id="NAND–most-fundamental"><a href="#NAND–most-fundamental" class="headerlink" title="NAND–most fundamental"></a>NAND–most fundamental</h3><ol><li>NAND gate :<br> <img src="/img/2023-07-31-16-42-04.png"></li><li><strong>if (a&#x3D;&#x3D;1 and b&#x3D;&#x3D;1) then out&#x3D;0 else out&#x3D;1</strong></li><li>Truth table:<br> <img src="/img/2023-07-31-16-43-35.png">  </li><li>三种基础门： <img src="/img/2023-07-31-16-44-36.png"></li><li>a AND b AND c :<img src="/img/2023-07-31-16-57-49.png"></li><li>再回忆一下电路实现——并联、串联。</li></ol><h2 id="unit-1-4-——-hardware-description-language"><a href="#unit-1-4-——-hardware-description-language" class="headerlink" title="unit 1.4 —— hardware description language!!!!!!!!!!"></a>unit 1.4 —— hardware description language!!!!!!!!!!</h2><ol><li><p>Xor :<br><img src="/img/2023-07-31-17-15-04.png"></p></li><li><p>器件名称必须用官方正式名称，没有自由度</p></li><li><p>Xor用硬件描述语言来实现：<br><img src="/img/2023-07-31-17-25-02.png"></p></li><li><p>what can we say in HDL?  </p><ul><li>缺陷：要有良好的文件保存；要想出良好的描述性名称（包括硬件和输出线路）。</li><li>最后两点最重要，类似一个已经确定好形参（虽然这个说法在c语言不太好，但是在这里很恰当）的函数，然后还有默认a，in，b是输入，out是输出的说法。<br><img src="/img/2023-07-31-17-31-24.png"></li></ul></li></ol><h2 id="unit-1-5-——-hardware-simulation"><a href="#unit-1-5-——-hardware-simulation" class="headerlink" title="unit 1.5 —— hardware simulation"></a>unit 1.5 —— hardware simulation</h2><h3 id="simulation-options"><a href="#simulation-options" class="headerlink" title="simulation options"></a>simulation options</h3><pre><code class="hljs">- interactive//互动性  - script-based  - with/without output and compare files  </code></pre><h3 id="some-hardware-操作指南"><a href="#some-hardware-操作指南" class="headerlink" title="some hardware 操作指南"></a>some hardware 操作指南</h3><ol><li>hardware simulation 是tools里面的同名.bat文件，双击即可，但是前提是要安装好Java。（因为该软件是Java写的）  </li><li>可以在vscode上面加配件来写hdl文件</li><li>上面的小黄纸是用来添加.tst文件的，左上的蓝色小箭头&gt;是用于调试的，可以把右上角的Decimal右边的，可能是script也可能是out,也可能是compare都可以调用。</li><li>.cmp文件是别人写好的优良对应芯片的测试输出结果，用于和我们生成的out文件对比是否正确。</li></ol><h2 id="unit-1-6-——-Multi-bit-Buses"><a href="#unit-1-6-——-Multi-bit-Buses" class="headerlink" title="unit 1.6 —— Multi-bit Buses"></a>unit 1.6 —— Multi-bit Buses</h2><ol><li>bus是一种类似于数组的概念</li><li>是从0开始的下标：  <img src="/img/2023-08-02-16-57-41.png"></li><li>中间值不用另外声明： <img src="/img/2023-08-02-16-59-26.png"></li><li>没有进位的四位加法器:<img src="/img/2023-08-02-17-03-22.png"></li><li>如果有一个A[16] 的bus，那么A[0]是最右边（最低有效位），A[15]是最左边（最高有效位），和c相反</li></ol><h2 id="unit-1-7-——-project-overview"><a href="#unit-1-7-——-project-overview" class="headerlink" title="unit 1.7 —— project overview"></a>unit 1.7 —— project overview</h2><h3 id="elementary-logic-gates"><a href="#elementary-logic-gates" class="headerlink" title="elementary logic gates"></a>elementary logic gates</h3><ol><li>multiplexor(数据选择器)</li></ol><ul><li>结构、描述、真值表：<img src="/img/2023-08-05-14-54-49.png"></li></ul><ol start="2"><li>demultiplexor(多路分配器)</li></ol><ul><li>结构、描述、真值表：<img src="/img/2023-08-05-14-59-55.png"></li></ul><ol start="3"><li><p>二者结合在通讯网络中的应用</p><ul><li>图纸：<img src="/img/2023-08-05-15-03-22.png"></li></ul></li></ol><h3 id="16-bit-chips"><a href="#16-bit-chips" class="headerlink" title="16-bit chips"></a>16-bit chips</h3><ol><li><p>And16</p><ul><li>图纸和原理：<img src="/img/2023-08-05-15-08-38.png"></li></ul></li></ol><h3 id="multi-way-多路变体"><a href="#multi-way-多路变体" class="headerlink" title="multi-way 多路变体"></a>multi-way 多路变体</h3><ol><li>结构图和真值表：<img src="/img/2023-08-05-15-17-17.png"></li></ol><h2 id="一些帮助性的网站在官网project1的第一个最下面"><a href="#一些帮助性的网站在官网project1的第一个最下面" class="headerlink" title="一些帮助性的网站在官网project1的第一个最下面"></a>一些帮助性的网站在官网project1的第一个最下面</h2><h2 id="门路名称网址"><a href="#门路名称网址" class="headerlink" title="门路名称网址"></a>门路名称网址</h2><p><a href="http://nand2tetris-questions-and-answers-forum.52.s1.nabble.com/Projects-1-5-List-of-Built-In-Chips-td4028133.html">http://nand2tetris-questions-and-answers-forum.52.s1.nabble.com/Projects-1-5-List-of-Built-In-Chips-td4028133.html</a></p>]]></content>
    
    
    <categories>
      
      <category>计组</category>
      
      <category>nand part I</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>cs61a 1</title>
    <link href="/2023/07/30/py-cs61a-1/"/>
    <url>/2023/07/30/py-cs61a-1/</url>
    
    <content type="html"><![CDATA[<h2 id="lecture-part"><a href="#lecture-part" class="headerlink" title="lecture part"></a>lecture part</h2><h3 id="Numeric-expressions"><a href="#Numeric-expressions" class="headerlink" title="Numeric expressions"></a>Numeric expressions</h3><p>2020<br>2000 + 20<br>-1 + 2 + 3 + 4 * ((5 &#x2F;&#x2F; 6) + 7 * 8 * 9)</p><h3 id="Call-expressions"><a href="#Call-expressions" class="headerlink" title="Call expressions"></a>Call expressions</h3><p><strong>max(3, 4.5)</strong> a,b可以是任何值，并且max和min里面可以有无限数量的值<br><strong>pow(100, 2)</strong><br><strong>min(3, 4.5)</strong><br>pow(2, 100)<br><strong>max(1, -2, 3, -4)</strong>  </p><h3 id="Importing-and-arithmetic-with-call-expressions"><a href="#Importing-and-arithmetic-with-call-expressions" class="headerlink" title="Importing and arithmetic with call expressions"></a>Importing and arithmetic with call expressions</h3><p>from operator import add, mul &#x2F;&#x2F;重要的在py里引入两个函数————两个数相加or相乘<br><strong>add(1, 2)</strong><br><strong>mul(4, 6)</strong><br>mul(add(4, mul(4, 6)), add(3, 5))<br><strong>add(4, mul(9, mul(add(4, mul(4, 6)), add(3, 5))))</strong> &#x2F;&#x2F;函数可以嵌套使用<br>对于py里函数的解释：<br><img src="/img/2023-07-31-20-53-50.png"></p><h3 id="Objects"><a href="#Objects" class="headerlink" title="Objects"></a>Objects</h3><h3 id="Note-Download-from-http-composingprograms-com-shakespeare-txt"><a href="#Note-Download-from-http-composingprograms-com-shakespeare-txt" class="headerlink" title="Note: Download from http://composingprograms.com/shakespeare.txt"></a>Note: Download from <a href="http://composingprograms.com/shakespeare.txt">http://composingprograms.com/shakespeare.txt</a></h3><p><strong>shakes &#x3D; open(‘shakespeare.txt’)</strong> &#x2F;&#x2F;把shakes声明为打开文件操作<br>注释一下py打开url的新操作</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> urllib.request <span class="hljs-keyword">import</span> urlopen//用了这行的话可以直接urlopen(<span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-keyword">import</span> urllib.request<br>htmlcode=urllib.request.urlopen(<span class="hljs-string">&quot;http://www.baidu.com&quot;</span>).read()<br><span class="hljs-built_in">print</span>(htmlcode)<br></code></pre></td></tr></table></figure><p><strong>text &#x3D; shakes.read().split()</strong>&#x2F;&#x2F;把text声明为打开、读取、分割好了的文件<br><strong>len(text)</strong>&#x2F;&#x2F;求长度<br><strong>text[:25]</strong>&#x2F;&#x2F;cat前25个字符串<br><strong>text.count(‘the’)</strong>&#x2F;&#x2F;计数，注意是’’单引号<br>text.count(‘thou’)<br>text.count(‘you’)<br>text.count(‘forsooth’)<br>text.count(‘,’)  </p><h3 id="Sets"><a href="#Sets" class="headerlink" title="Sets"></a>Sets</h3><p><strong>words &#x3D; set(text)</strong>&#x2F;&#x2F;设置为一个字符集合，会删去重复的<br><strong>len(words)</strong>&#x2F;&#x2F;长度<br><strong>max(words)</strong> &#x2F;&#x2F;This line finds the maximum element in the words set. When applied to a set of strings, max() will return the “maximum” string based on 字母顺序. In this context, it will return the last word when the words are sorted in 字母顺序.<br><strong>max(words, key&#x3D;len)</strong>  &#x2F;&#x2F;This line finds the maximum element in the words set based <strong>on the length of each word</strong>. The <strong>key&#x3D;len</strong> argument is indicating that the comparison should be based on the length of the words rather than their 字母顺序. As a result, it will return the longest word in the set. </p><h3 id="Reversals"><a href="#Reversals" class="headerlink" title="Reversals"></a>Reversals</h3><p><strong>‘draw’[::-1]</strong>&#x2F;&#x2F;回文切换<br><strong>‘character’ in words &gt;&gt;&gt; True&#x2F;False</strong>&#x2F;&#x2F;判断是否在合集里<br><strong>{w for w in words if w &#x3D;&#x3D; w[::-1] and len(w)&gt;4}</strong>&#x2F;&#x2F;把w换成a都行，查找在字符集合words里的回文字符<br><strong>{w for w in words if w[::-1] in words and len(w) &#x3D;&#x3D; 4}</strong>&#x2F;&#x2F;都在words里出现过的<br><strong>{w for w in words if w[::-1] in words and len(w) &gt; 6}</strong>  </p><p><img src="/img/2023-07-31-23-25-00.png"></p><h2 id="capture-part-——-只有第一节有，和lecture一模一样，不用看，浪费时间"><a href="#capture-part-——-只有第一节有，和lecture一模一样，不用看，浪费时间" class="headerlink" title="capture part —— 只有第一节有，和lecture一模一样，不用看，浪费时间"></a>capture part —— 只有第一节有，和lecture一模一样，不用看，浪费时间</h2>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
      <category>cs61a</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>cs61a 2</title>
    <link href="/2023/07/30/py-cs61a-2/"/>
    <url>/2023/07/30/py-cs61a-2/</url>
    
    <content type="html"><![CDATA[<h2 id="Imports"><a href="#Imports" class="headerlink" title="Imports"></a>Imports</h2><p><strong>from math import pi</strong>&#x2F;&#x2F;引入math库里的pi<br>pi * 71 &#x2F; 223<br><strong>from math import sin</strong><br>sin(pi&#x2F;2)<br><strong>from math import sub, sqrt</strong>&#x2F;&#x2F;pow不用,sub是减法,sqrt开根<br>依旧是math库，替代&#x2F;和&#x2F;&#x2F;的：<img src="/img/2023-08-04-20-09-40.png">  </p><h2 id="pure-function"><a href="#pure-function" class="headerlink" title="pure function"></a>pure function</h2><p>Functions have some input (their arguments) and return some output (the result of applying them). </p><h2 id="some-built-in-functions"><a href="#some-built-in-functions" class="headerlink" title="some built_in functions"></a>some built_in functions</h2><ol><li><strong>abs()</strong> &#x2F;&#x2F;绝对值函数，是pure函数  </li><li><strong>print(,,,,)</strong> &#x2F;&#x2F;不是pure函数,输出print内的值,返回None，可以试试：<img src="/img/2023-08-04-19-09-13.png"></li></ol><h3 id="Assignment（伴有神奇的交换语句）"><a href="#Assignment（伴有神奇的交换语句）" class="headerlink" title="Assignment（伴有神奇的交换语句）"></a>Assignment（伴有神奇的交换语句）</h3><p>radius &#x3D; 10<br>2 * radius<br>area, circ &#x3D; pi * radius * radius, 2 * pi * radius&#x2F;&#x2F;很特殊的声明方式<br>radius &#x3D; 20&#x2F;&#x2F;不会记忆前面的内容，因此area不会改变<br><strong>奇妙的赋值语句：</strong><img src="/img/2023-08-04-18-59-58.png"></p><h3 id="Function-values"><a href="#Function-values" class="headerlink" title="Function values"></a>Function values</h3><p>max<br>max(3, 4)<br><strong>f &#x3D; max</strong>&#x2F;&#x2F;把f声明为max函数，可以执行max函数的功能<br><strong>f</strong><br><strong>f(3, 4)</strong><br>max &#x3D; 7&#x2F;&#x2F;把max当作变量赋值<br>f(3, 4)<br>f(3, max)<br>f &#x3D; 2  </p><h3 id="User-defined-functions"><a href="#User-defined-functions" class="headerlink" title="User-defined functions"></a>User-defined functions</h3><p>from operator import add, mul</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py"><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">square</span>(<span class="hljs-params">x</span>)://定义一个函数，在结尾加一个回车就定义成功了<br>    <span class="hljs-keyword">return</span> mul(x, x)<br><br></code></pre></td></tr></table></figure><p>直接 <code>square</code> 会显示在内存的位置</p><p>square(21)<br>square(add(2, 5))<br>square(square(3))</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">sum_squares</span>(<span class="hljs-params">x, y</span>):<br>    <span class="hljs-keyword">return</span> add(square(x), square(y))<br><br></code></pre></td></tr></table></figure><p>sum_squares(3, 4)<br>sum_squares(5, 12)</p><h3 id="area-function"><a href="#area-function" class="headerlink" title="area function"></a>area function</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">area</span>():<br>    <span class="hljs-keyword">return</span> pi * radius * radius<br><br></code></pre></td></tr></table></figure><p>area()<br>radius &#x3D; 20<br>area()<br>radius &#x3D; 10<br>area()</p><h3 id="Name-conflicts"><a href="#Name-conflicts" class="headerlink" title="Name conflicts"></a>Name conflicts</h3><p>def square(square):<br>    return mul(square, square)<br>square(4)</p><h2 id="environment-diagram"><a href="#environment-diagram" class="headerlink" title="environment diagram"></a>environment diagram</h2><ol><li><strong>debug || frame&#x2F; environment diagram</strong>：<a href="https://pythontutor.com/cp/composingprograms.html#mode=edit">https://pythontutor.com/cp/composingprograms.html#mode=edit</a> 说是画什么框架图，在我看来就是用来<strong>debug</strong>的</li><li>一个很好利用上述网站的例子（活用树状图）：<img src="/img/2023-08-04-14-48-33.png"></li></ol><h2 id="define-functions"><a href="#define-functions" class="headerlink" title="define functions"></a>define functions</h2><ol><li>格式：<img src="/img/2023-08-04-14-54-46.png"></li></ol>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
      <category>cs61a</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>the important cmd in git</title>
    <link href="/2023/07/29/git_learning/"/>
    <url>/2023/07/29/git_learning/</url>
    
    <content type="html"><![CDATA[<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://blog.csdn.net/qq_52596258/article/details/119643715">https://blog.csdn.net/qq_52596258/article/details/119643715</a></p><h2 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a>git config</h2><p>–global user.name&#x2F;email 设立<br>user.name&#x2F;email 查询<br>–list 查询</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol><li><strong>mkdir</strong> 文件夹当库  </li><li><strong>git init</strong> 初始化为库(里面会生成一个,git文件不要删)  </li><li><strong>touch(vim)</strong> xx.txt&#x2F;.c ……创建文件  </li><li><strong>:wq&#x2F;ZZ</strong> 保存并退出</li><li><strong>git status</strong> 查询状态</li><li><strong>git add</strong> xx.txt 添加到缓存区</li><li><strong>cat</strong> xx.txt 可以投射文件</li><li><strong>git commit -m</strong> “操作名(方便日后查日志)”</li><li>到这里就存好了！！！</li></ol><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><ol><li>默认已经修改了xx.txt文件</li><li><strong>git add</strong> xx.txt</li><li><strong>git commit -m “append GPL”</strong> 提交到版本库</li><li><strong>git log</strong>查看提交日志</li><li>要提交**git commit -m “XX”**后才能加修改</li></ol><h2 id="回到某个版本"><a href="#回到某个版本" class="headerlink" title="回到某个版本"></a>回到某个版本</h2><p>&#x2F;&#x2F; 学到了2.2累了</p><p>&#x2F;&#x2F;2023.07.30更新：太监了，懒得学了，浪费时间，学vim去了——end  </p>]]></content>
    
    
    <categories>
      
      <category>Cmd_learnig</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
